/* automatically generated by rust-bindgen 0.60.1 */

pub const INCLUDED_OPENEXR_CONFIG_H: u32 = 1;
pub const OPENEXR_IMF_INTERNAL_NAMESPACE_CUSTOM: u32 = 0;
pub const OPENEXR_IMF_NAMESPACE_CUSTOM: u32 = 0;
pub const OPENEXR_VERSION_STRING: &[u8; 6usize] = b"3.1.5\0";
pub const OPENEXR_PACKAGE_STRING: &[u8; 14usize] = b"OpenEXR 3.1.5\0";
pub const OPENEXR_VERSION_MAJOR: u32 = 3;
pub const OPENEXR_VERSION_MINOR: u32 = 1;
pub const OPENEXR_VERSION_PATCH: u32 = 5;
pub const OPENEXR_VERSION_RELEASE_TYPE: &[u8; 1usize] = b"\0";
pub const OPENEXR_VERSION_EXTRA: &[u8; 1usize] = b"\0";
pub const OPENEXR_LIB_VERSION_STRING: &[u8; 7usize] = b"30.5.1\0";
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const EXR_CONTEXT_FLAG_STRICT_HEADER: u32 = 1;
pub const EXR_CONTEXT_FLAG_SILENT_HEADER_PARSE: u32 = 2;
pub const EXR_CONTEXT_FLAG_DISABLE_CHUNK_RECONSTRUCTION: u32 = 4;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
extern "C" {
    pub fn exr_get_library_version(
        maj: *mut ::std::os::raw::c_int,
        min: *mut ::std::os::raw::c_int,
        patch: *mut ::std::os::raw::c_int,
        extra: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn exr_set_default_maximum_image_size(w: ::std::os::raw::c_int, h: ::std::os::raw::c_int);
}
extern "C" {
    pub fn exr_get_default_maximum_image_size(
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exr_set_default_maximum_tile_size(w: ::std::os::raw::c_int, h: ::std::os::raw::c_int);
}
extern "C" {
    pub fn exr_get_default_maximum_tile_size(
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exr_set_default_zip_compression_level(l: ::std::os::raw::c_int);
}
extern "C" {
    pub fn exr_get_default_zip_compression_level(l: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn exr_set_default_dwa_compression_quality(q: f32);
}
extern "C" {
    pub fn exr_get_default_dwa_compression_quality(q: *mut f32);
}
pub type exr_memory_allocation_func_t =
    ::std::option::Option<unsafe extern "C" fn(bytes: usize) -> *mut ::std::os::raw::c_void>;
pub type exr_memory_free_func_t =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn exr_set_default_memory_routines(
        alloc_func: exr_memory_allocation_func_t,
        free_func: exr_memory_free_func_t,
    );
}
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
impl exr_error_code_t {
    pub const EXR_ERR_SUCCESS: exr_error_code_t = exr_error_code_t(0);
}
impl exr_error_code_t {
    pub const EXR_ERR_OUT_OF_MEMORY: exr_error_code_t = exr_error_code_t(1);
}
impl exr_error_code_t {
    pub const EXR_ERR_MISSING_CONTEXT_ARG: exr_error_code_t = exr_error_code_t(2);
}
impl exr_error_code_t {
    pub const EXR_ERR_INVALID_ARGUMENT: exr_error_code_t = exr_error_code_t(3);
}
impl exr_error_code_t {
    pub const EXR_ERR_ARGUMENT_OUT_OF_RANGE: exr_error_code_t = exr_error_code_t(4);
}
impl exr_error_code_t {
    pub const EXR_ERR_FILE_ACCESS: exr_error_code_t = exr_error_code_t(5);
}
impl exr_error_code_t {
    pub const EXR_ERR_FILE_BAD_HEADER: exr_error_code_t = exr_error_code_t(6);
}
impl exr_error_code_t {
    pub const EXR_ERR_NOT_OPEN_READ: exr_error_code_t = exr_error_code_t(7);
}
impl exr_error_code_t {
    pub const EXR_ERR_NOT_OPEN_WRITE: exr_error_code_t = exr_error_code_t(8);
}
impl exr_error_code_t {
    pub const EXR_ERR_HEADER_NOT_WRITTEN: exr_error_code_t = exr_error_code_t(9);
}
impl exr_error_code_t {
    pub const EXR_ERR_READ_IO: exr_error_code_t = exr_error_code_t(10);
}
impl exr_error_code_t {
    pub const EXR_ERR_WRITE_IO: exr_error_code_t = exr_error_code_t(11);
}
impl exr_error_code_t {
    pub const EXR_ERR_NAME_TOO_LONG: exr_error_code_t = exr_error_code_t(12);
}
impl exr_error_code_t {
    pub const EXR_ERR_MISSING_REQ_ATTR: exr_error_code_t = exr_error_code_t(13);
}
impl exr_error_code_t {
    pub const EXR_ERR_INVALID_ATTR: exr_error_code_t = exr_error_code_t(14);
}
impl exr_error_code_t {
    pub const EXR_ERR_NO_ATTR_BY_NAME: exr_error_code_t = exr_error_code_t(15);
}
impl exr_error_code_t {
    pub const EXR_ERR_ATTR_TYPE_MISMATCH: exr_error_code_t = exr_error_code_t(16);
}
impl exr_error_code_t {
    pub const EXR_ERR_ATTR_SIZE_MISMATCH: exr_error_code_t = exr_error_code_t(17);
}
impl exr_error_code_t {
    pub const EXR_ERR_SCAN_TILE_MIXEDAPI: exr_error_code_t = exr_error_code_t(18);
}
impl exr_error_code_t {
    pub const EXR_ERR_TILE_SCAN_MIXEDAPI: exr_error_code_t = exr_error_code_t(19);
}
impl exr_error_code_t {
    pub const EXR_ERR_MODIFY_SIZE_CHANGE: exr_error_code_t = exr_error_code_t(20);
}
impl exr_error_code_t {
    pub const EXR_ERR_ALREADY_WROTE_ATTRS: exr_error_code_t = exr_error_code_t(21);
}
impl exr_error_code_t {
    pub const EXR_ERR_BAD_CHUNK_LEADER: exr_error_code_t = exr_error_code_t(22);
}
impl exr_error_code_t {
    pub const EXR_ERR_CORRUPT_CHUNK: exr_error_code_t = exr_error_code_t(23);
}
impl exr_error_code_t {
    pub const EXR_ERR_INCORRECT_PART: exr_error_code_t = exr_error_code_t(24);
}
impl exr_error_code_t {
    pub const EXR_ERR_INCORRECT_CHUNK: exr_error_code_t = exr_error_code_t(25);
}
impl exr_error_code_t {
    pub const EXR_ERR_USE_SCAN_DEEP_WRITE: exr_error_code_t = exr_error_code_t(26);
}
impl exr_error_code_t {
    pub const EXR_ERR_USE_TILE_DEEP_WRITE: exr_error_code_t = exr_error_code_t(27);
}
impl exr_error_code_t {
    pub const EXR_ERR_USE_SCAN_NONDEEP_WRITE: exr_error_code_t = exr_error_code_t(28);
}
impl exr_error_code_t {
    pub const EXR_ERR_USE_TILE_NONDEEP_WRITE: exr_error_code_t = exr_error_code_t(29);
}
impl exr_error_code_t {
    pub const EXR_ERR_INVALID_SAMPLE_DATA: exr_error_code_t = exr_error_code_t(30);
}
impl exr_error_code_t {
    pub const EXR_ERR_FEATURE_NOT_IMPLEMENTED: exr_error_code_t = exr_error_code_t(31);
}
impl exr_error_code_t {
    pub const EXR_ERR_UNKNOWN: exr_error_code_t = exr_error_code_t(32);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_error_code_t(pub ::std::os::raw::c_int);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct exr_result_t(pub i32);
extern "C" {
    pub fn exr_get_default_error_message(code: exr_result_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exr_get_error_code_as_string(code: exr_result_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _priv_exr_context_t {
    _unused: [u8; 0],
}
pub type exr_context_t = *mut _priv_exr_context_t;
pub type exr_const_context_t = *const _priv_exr_context_t;
pub type exr_stream_error_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        code: exr_result_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> exr_result_t,
>;
pub type exr_error_handler_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        code: exr_result_t,
        msg: *const ::std::os::raw::c_char,
    ),
>;
pub type exr_destroy_stream_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
        failed: ::std::os::raw::c_int,
    ),
>;
pub type exr_query_size_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(ctxt: exr_const_context_t, userdata: *mut ::std::os::raw::c_void) -> i64,
>;
pub type exr_read_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
        sz: u64,
        offset: u64,
        error_cb: exr_stream_error_func_ptr_t,
    ) -> i64,
>;
pub type exr_write_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_void,
        sz: u64,
        offset: u64,
        error_cb: exr_stream_error_func_ptr_t,
    ) -> i64,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _exr_context_initializer_v3 {
    pub size: usize,
    pub error_handler_fn: exr_error_handler_cb_t,
    pub alloc_fn: exr_memory_allocation_func_t,
    pub free_fn: exr_memory_free_func_t,
    pub user_data: *mut ::std::os::raw::c_void,
    pub read_fn: exr_read_func_ptr_t,
    pub size_fn: exr_query_size_func_ptr_t,
    pub write_fn: exr_write_func_ptr_t,
    pub destroy_fn: exr_destroy_stream_func_ptr_t,
    pub max_image_width: ::std::os::raw::c_int,
    pub max_image_height: ::std::os::raw::c_int,
    pub max_tile_width: ::std::os::raw::c_int,
    pub max_tile_height: ::std::os::raw::c_int,
    pub zip_level: ::std::os::raw::c_int,
    pub dwa_quality: f32,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__exr_context_initializer_v3() {
    assert_eq!(
        ::std::mem::size_of::<_exr_context_initializer_v3>(),
        104usize,
        concat!("Size of: ", stringify!(_exr_context_initializer_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<_exr_context_initializer_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(_exr_context_initializer_v3))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_error_handler_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error_handler_fn) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(error_handler_fn)
            )
        );
    }
    test_field_error_handler_fn();
    fn test_field_alloc_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alloc_fn) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(alloc_fn)
            )
        );
    }
    test_field_alloc_fn();
    fn test_field_free_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_fn) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(free_fn)
            )
        );
    }
    test_field_free_fn();
    fn test_field_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(user_data)
            )
        );
    }
    test_field_user_data();
    fn test_field_read_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_fn) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(read_fn)
            )
        );
    }
    test_field_read_fn();
    fn test_field_size_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size_fn) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(size_fn)
            )
        );
    }
    test_field_size_fn();
    fn test_field_write_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_fn) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(write_fn)
            )
        );
    }
    test_field_write_fn();
    fn test_field_destroy_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy_fn) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(destroy_fn)
            )
        );
    }
    test_field_destroy_fn();
    fn test_field_max_image_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_image_width) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(max_image_width)
            )
        );
    }
    test_field_max_image_width();
    fn test_field_max_image_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_image_height) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(max_image_height)
            )
        );
    }
    test_field_max_image_height();
    fn test_field_max_tile_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_tile_width) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(max_tile_width)
            )
        );
    }
    test_field_max_tile_width();
    fn test_field_max_tile_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_tile_height) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(max_tile_height)
            )
        );
    }
    test_field_max_tile_height();
    fn test_field_zip_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zip_level) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(zip_level)
            )
        );
    }
    test_field_zip_level();
    fn test_field_dwa_quality() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwa_quality) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(dwa_quality)
            )
        );
    }
    test_field_dwa_quality();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_context_initializer_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_context_initializer_v3),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
pub type exr_context_initializer_t = _exr_context_initializer_v3;
extern "C" {
    pub fn exr_test_file_header(
        filename: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_finish(ctxt: *mut exr_context_t) -> exr_result_t;
}
extern "C" {
    pub fn exr_start_read(
        ctxt: *mut exr_context_t,
        filename: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
impl exr_default_write_mode {
    pub const EXR_WRITE_FILE_DIRECTLY: exr_default_write_mode = exr_default_write_mode(0);
}
impl exr_default_write_mode {
    pub const EXR_INTERMEDIATE_TEMP_FILE: exr_default_write_mode = exr_default_write_mode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_default_write_mode(pub ::std::os::raw::c_int);
pub use self::exr_default_write_mode as exr_default_write_mode_t;
extern "C" {
    pub fn exr_start_write(
        ctxt: *mut exr_context_t,
        filename: *const ::std::os::raw::c_char,
        default_mode: exr_default_write_mode_t,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_start_inplace_header_update(
        ctxt: *mut exr_context_t,
        filename: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_file_name(
        ctxt: exr_const_context_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_user_data(
        ctxt: exr_const_context_t,
        userdata: *mut *mut ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_register_attr_type_handler(
        ctxt: exr_context_t,
        type_: *const ::std::os::raw::c_char,
        unpack_func_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                ctxt: exr_context_t,
                data: *const ::std::os::raw::c_void,
                attrsize: i32,
                outsize: *mut i32,
                outbuffer: *mut *mut ::std::os::raw::c_void,
            ) -> exr_result_t,
        >,
        pack_func_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                ctxt: exr_context_t,
                data: *const ::std::os::raw::c_void,
                datasize: i32,
                outsize: *mut i32,
                outbuffer: *mut ::std::os::raw::c_void,
            ) -> exr_result_t,
        >,
        destroy_unpacked_func_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                ctxt: exr_context_t,
                data: *mut ::std::os::raw::c_void,
                datasize: i32,
            ),
        >,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_longname_support(
        ctxt: exr_context_t,
        onoff: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_header(ctxt: exr_context_t) -> exr_result_t;
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_NONE: exr_compression_t = exr_compression_t(0);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_RLE: exr_compression_t = exr_compression_t(1);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_ZIPS: exr_compression_t = exr_compression_t(2);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_ZIP: exr_compression_t = exr_compression_t(3);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_PIZ: exr_compression_t = exr_compression_t(4);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_PXR24: exr_compression_t = exr_compression_t(5);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_B44: exr_compression_t = exr_compression_t(6);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_B44A: exr_compression_t = exr_compression_t(7);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_DWAA: exr_compression_t = exr_compression_t(8);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_DWAB: exr_compression_t = exr_compression_t(9);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_LAST_TYPE: exr_compression_t = exr_compression_t(10);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_compression_t(pub ::std::os::raw::c_int);
impl exr_envmap_t {
    pub const EXR_ENVMAP_LATLONG: exr_envmap_t = exr_envmap_t(0);
}
impl exr_envmap_t {
    pub const EXR_ENVMAP_CUBE: exr_envmap_t = exr_envmap_t(1);
}
impl exr_envmap_t {
    pub const EXR_ENVMAP_LAST_TYPE: exr_envmap_t = exr_envmap_t(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_envmap_t(pub ::std::os::raw::c_int);
impl exr_lineorder_t {
    pub const EXR_LINEORDER_INCREASING_Y: exr_lineorder_t = exr_lineorder_t(0);
}
impl exr_lineorder_t {
    pub const EXR_LINEORDER_DECREASING_Y: exr_lineorder_t = exr_lineorder_t(1);
}
impl exr_lineorder_t {
    pub const EXR_LINEORDER_RANDOM_Y: exr_lineorder_t = exr_lineorder_t(2);
}
impl exr_lineorder_t {
    pub const EXR_LINEORDER_LAST_TYPE: exr_lineorder_t = exr_lineorder_t(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_lineorder_t(pub ::std::os::raw::c_int);
impl exr_storage_t {
    pub const EXR_STORAGE_SCANLINE: exr_storage_t = exr_storage_t(0);
}
impl exr_storage_t {
    pub const EXR_STORAGE_TILED: exr_storage_t = exr_storage_t(1);
}
impl exr_storage_t {
    pub const EXR_STORAGE_DEEP_SCANLINE: exr_storage_t = exr_storage_t(2);
}
impl exr_storage_t {
    pub const EXR_STORAGE_DEEP_TILED: exr_storage_t = exr_storage_t(3);
}
impl exr_storage_t {
    pub const EXR_STORAGE_LAST_TYPE: exr_storage_t = exr_storage_t(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_storage_t(pub ::std::os::raw::c_int);
impl exr_tile_level_mode_t {
    pub const EXR_TILE_ONE_LEVEL: exr_tile_level_mode_t = exr_tile_level_mode_t(0);
}
impl exr_tile_level_mode_t {
    pub const EXR_TILE_MIPMAP_LEVELS: exr_tile_level_mode_t = exr_tile_level_mode_t(1);
}
impl exr_tile_level_mode_t {
    pub const EXR_TILE_RIPMAP_LEVELS: exr_tile_level_mode_t = exr_tile_level_mode_t(2);
}
impl exr_tile_level_mode_t {
    pub const EXR_TILE_LAST_TYPE: exr_tile_level_mode_t = exr_tile_level_mode_t(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_tile_level_mode_t(pub ::std::os::raw::c_int);
impl exr_tile_round_mode_t {
    pub const EXR_TILE_ROUND_DOWN: exr_tile_round_mode_t = exr_tile_round_mode_t(0);
}
impl exr_tile_round_mode_t {
    pub const EXR_TILE_ROUND_UP: exr_tile_round_mode_t = exr_tile_round_mode_t(1);
}
impl exr_tile_round_mode_t {
    pub const EXR_TILE_ROUND_LAST_TYPE: exr_tile_round_mode_t = exr_tile_round_mode_t(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_tile_round_mode_t(pub ::std::os::raw::c_int);
impl exr_pixel_type_t {
    pub const EXR_PIXEL_UINT: exr_pixel_type_t = exr_pixel_type_t(0);
}
impl exr_pixel_type_t {
    pub const EXR_PIXEL_HALF: exr_pixel_type_t = exr_pixel_type_t(1);
}
impl exr_pixel_type_t {
    pub const EXR_PIXEL_FLOAT: exr_pixel_type_t = exr_pixel_type_t(2);
}
impl exr_pixel_type_t {
    pub const EXR_PIXEL_LAST_TYPE: exr_pixel_type_t = exr_pixel_type_t(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_pixel_type_t(pub ::std::os::raw::c_int);
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_chromaticities_t {
    pub red_x: f32,
    pub red_y: f32,
    pub green_x: f32,
    pub green_y: f32,
    pub blue_x: f32,
    pub blue_y: f32,
    pub white_x: f32,
    pub white_y: f32,
}
#[test]
fn bindgen_test_layout_exr_attr_chromaticities_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_chromaticities_t>(),
        32usize,
        concat!("Size of: ", stringify!(exr_attr_chromaticities_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_chromaticities_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_chromaticities_t))
    );
    fn test_field_red_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chromaticities_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).red_x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chromaticities_t),
                "::",
                stringify!(red_x)
            )
        );
    }
    test_field_red_x();
    fn test_field_red_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chromaticities_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).red_y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chromaticities_t),
                "::",
                stringify!(red_y)
            )
        );
    }
    test_field_red_y();
    fn test_field_green_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chromaticities_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).green_x) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chromaticities_t),
                "::",
                stringify!(green_x)
            )
        );
    }
    test_field_green_x();
    fn test_field_green_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chromaticities_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).green_y) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chromaticities_t),
                "::",
                stringify!(green_y)
            )
        );
    }
    test_field_green_y();
    fn test_field_blue_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chromaticities_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blue_x) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chromaticities_t),
                "::",
                stringify!(blue_x)
            )
        );
    }
    test_field_blue_x();
    fn test_field_blue_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chromaticities_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blue_y) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chromaticities_t),
                "::",
                stringify!(blue_y)
            )
        );
    }
    test_field_blue_y();
    fn test_field_white_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chromaticities_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).white_x) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chromaticities_t),
                "::",
                stringify!(white_x)
            )
        );
    }
    test_field_white_x();
    fn test_field_white_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chromaticities_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).white_y) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chromaticities_t),
                "::",
                stringify!(white_y)
            )
        );
    }
    test_field_white_y();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_keycode_t {
    pub film_mfc_code: i32,
    pub film_type: i32,
    pub prefix: i32,
    pub count: i32,
    pub perf_offset: i32,
    pub perfs_per_frame: i32,
    pub perfs_per_count: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_keycode_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_keycode_t>(),
        28usize,
        concat!("Size of: ", stringify!(exr_attr_keycode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_keycode_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_keycode_t))
    );
    fn test_field_film_mfc_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_keycode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).film_mfc_code) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_keycode_t),
                "::",
                stringify!(film_mfc_code)
            )
        );
    }
    test_field_film_mfc_code();
    fn test_field_film_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_keycode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).film_type) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_keycode_t),
                "::",
                stringify!(film_type)
            )
        );
    }
    test_field_film_type();
    fn test_field_prefix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_keycode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_keycode_t),
                "::",
                stringify!(prefix)
            )
        );
    }
    test_field_prefix();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_keycode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_keycode_t),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_perf_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_keycode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).perf_offset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_keycode_t),
                "::",
                stringify!(perf_offset)
            )
        );
    }
    test_field_perf_offset();
    fn test_field_perfs_per_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_keycode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).perfs_per_frame) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_keycode_t),
                "::",
                stringify!(perfs_per_frame)
            )
        );
    }
    test_field_perfs_per_frame();
    fn test_field_perfs_per_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_keycode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).perfs_per_count) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_keycode_t),
                "::",
                stringify!(perfs_per_count)
            )
        );
    }
    test_field_perfs_per_count();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m33f_t {
    pub m: [f32; 9usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m33f_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m33f_t>(),
        36usize,
        concat!("Size of: ", stringify!(exr_attr_m33f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m33f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m33f_t))
    );
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_m33f_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_m33f_t),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m33d_t {
    pub m: [f64; 9usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m33d_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m33d_t>(),
        72usize,
        concat!("Size of: ", stringify!(exr_attr_m33d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m33d_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m33d_t))
    );
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_m33d_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_m33d_t),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m44f_t {
    pub m: [f32; 16usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m44f_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m44f_t>(),
        64usize,
        concat!("Size of: ", stringify!(exr_attr_m44f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m44f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m44f_t))
    );
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_m44f_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_m44f_t),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m44d_t {
    pub m: [f64; 16usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m44d_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m44d_t>(),
        128usize,
        concat!("Size of: ", stringify!(exr_attr_m44d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m44d_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m44d_t))
    );
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_m44d_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_m44d_t),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_rational_t {
    pub num: i32,
    pub denom: u32,
}
#[test]
fn bindgen_test_layout_exr_attr_rational_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_rational_t>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_rational_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_rational_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_rational_t))
    );
    fn test_field_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_rational_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_rational_t),
                "::",
                stringify!(num)
            )
        );
    }
    test_field_num();
    fn test_field_denom() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_rational_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_rational_t),
                "::",
                stringify!(denom)
            )
        );
    }
    test_field_denom();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_timecode_t {
    pub time_and_flags: u32,
    pub user_data: u32,
}
#[test]
fn bindgen_test_layout_exr_attr_timecode_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_timecode_t>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_timecode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_timecode_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_timecode_t))
    );
    fn test_field_time_and_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_timecode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_and_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_timecode_t),
                "::",
                stringify!(time_and_flags)
            )
        );
    }
    test_field_time_and_flags();
    fn test_field_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_timecode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_timecode_t),
                "::",
                stringify!(user_data)
            )
        );
    }
    test_field_user_data();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attr_v2i_t {
    pub __bindgen_anon_1: exr_attr_v2i_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v2i_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [i32; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[test]
fn bindgen_test_layout_exr_attr_v2i_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2i_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_v2i_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2i_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v2i_t__bindgen_ty_1))
    );
    fn test_field_arr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_v2i_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v2i_t__bindgen_ty_1),
                "::",
                stringify!(arr)
            )
        );
    }
    test_field_arr();
}
#[test]
fn bindgen_test_layout_exr_attr_v2i_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2i_t>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_v2i_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2i_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v2i_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attr_v2f_t {
    pub __bindgen_anon_1: exr_attr_v2f_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v2f_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [f32; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[test]
fn bindgen_test_layout_exr_attr_v2f_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2f_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_v2f_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2f_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v2f_t__bindgen_ty_1))
    );
    fn test_field_arr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_v2f_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v2f_t__bindgen_ty_1),
                "::",
                stringify!(arr)
            )
        );
    }
    test_field_arr();
}
#[test]
fn bindgen_test_layout_exr_attr_v2f_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2f_t>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_v2f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v2f_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attr_v2d_t {
    pub __bindgen_anon_1: exr_attr_v2d_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v2d_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [f64; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[test]
fn bindgen_test_layout_exr_attr_v2d_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2d_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_v2d_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2d_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v2d_t__bindgen_ty_1))
    );
    fn test_field_arr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_v2d_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v2d_t__bindgen_ty_1),
                "::",
                stringify!(arr)
            )
        );
    }
    test_field_arr();
}
#[test]
fn bindgen_test_layout_exr_attr_v2d_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2d_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_v2d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2d_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v2d_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attr_v3i_t {
    pub __bindgen_anon_1: exr_attr_v3i_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v3i_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [i32; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[test]
fn bindgen_test_layout_exr_attr_v3i_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3i_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(exr_attr_v3i_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3i_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v3i_t__bindgen_ty_1))
    );
    fn test_field_arr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_v3i_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3i_t__bindgen_ty_1),
                "::",
                stringify!(arr)
            )
        );
    }
    test_field_arr();
}
#[test]
fn bindgen_test_layout_exr_attr_v3i_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3i_t>(),
        12usize,
        concat!("Size of: ", stringify!(exr_attr_v3i_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3i_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v3i_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attr_v3f_t {
    pub __bindgen_anon_1: exr_attr_v3f_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v3f_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [f32; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[test]
fn bindgen_test_layout_exr_attr_v3f_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3f_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(exr_attr_v3f_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3f_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v3f_t__bindgen_ty_1))
    );
    fn test_field_arr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_v3f_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3f_t__bindgen_ty_1),
                "::",
                stringify!(arr)
            )
        );
    }
    test_field_arr();
}
#[test]
fn bindgen_test_layout_exr_attr_v3f_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3f_t>(),
        12usize,
        concat!("Size of: ", stringify!(exr_attr_v3f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v3f_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attr_v3d_t {
    pub __bindgen_anon_1: exr_attr_v3d_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v3d_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [f64; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[test]
fn bindgen_test_layout_exr_attr_v3d_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3d_t__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(exr_attr_v3d_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3d_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v3d_t__bindgen_ty_1))
    );
    fn test_field_arr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_v3d_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_v3d_t__bindgen_ty_1),
                "::",
                stringify!(arr)
            )
        );
    }
    test_field_arr();
}
#[test]
fn bindgen_test_layout_exr_attr_v3d_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3d_t>(),
        24usize,
        concat!("Size of: ", stringify!(exr_attr_v3d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3d_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v3d_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attr_box2i_t {
    pub min: exr_attr_v2i_t,
    pub max: exr_attr_v2i_t,
}
#[test]
fn bindgen_test_layout_exr_attr_box2i_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_box2i_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_box2i_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_box2i_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_box2i_t))
    );
    fn test_field_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_box2i_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_box2i_t),
                "::",
                stringify!(min)
            )
        );
    }
    test_field_min();
    fn test_field_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_box2i_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_box2i_t),
                "::",
                stringify!(max)
            )
        );
    }
    test_field_max();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attr_box2f_t {
    pub min: exr_attr_v2f_t,
    pub max: exr_attr_v2f_t,
}
#[test]
fn bindgen_test_layout_exr_attr_box2f_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_box2f_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_box2f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_box2f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_box2f_t))
    );
    fn test_field_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_box2f_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_box2f_t),
                "::",
                stringify!(min)
            )
        );
    }
    test_field_min();
    fn test_field_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_box2f_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_box2f_t),
                "::",
                stringify!(max)
            )
        );
    }
    test_field_max();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_tiledesc_t {
    pub x_size: u32,
    pub y_size: u32,
    pub level_and_round: u8,
}
#[test]
fn bindgen_test_layout_exr_attr_tiledesc_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_tiledesc_t>(),
        9usize,
        concat!("Size of: ", stringify!(exr_attr_tiledesc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_tiledesc_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_tiledesc_t))
    );
    fn test_field_x_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_tiledesc_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x_size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_tiledesc_t),
                "::",
                stringify!(x_size)
            )
        );
    }
    test_field_x_size();
    fn test_field_y_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_tiledesc_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_tiledesc_t),
                "::",
                stringify!(y_size)
            )
        );
    }
    test_field_y_size();
    fn test_field_level_and_round() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_tiledesc_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).level_and_round) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_tiledesc_t),
                "::",
                stringify!(level_and_round)
            )
        );
    }
    test_field_level_and_round();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_string_t {
    pub length: i32,
    pub alloc_size: i32,
    pub str_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_exr_attr_string_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_string_t))
    );
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_string_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_string_t),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_string_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_string_t),
                "::",
                stringify!(alloc_size)
            )
        );
    }
    test_field_alloc_size();
    fn test_field_str() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_string_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_string_t),
                "::",
                stringify!(str_)
            )
        );
    }
    test_field_str();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_string_vector_t {
    pub n_strings: i32,
    pub alloc_size: i32,
    pub strings: *const exr_attr_string_t,
}
#[test]
fn bindgen_test_layout_exr_attr_string_vector_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_string_vector_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_string_vector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_string_vector_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_string_vector_t))
    );
    fn test_field_n_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_string_vector_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_strings) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_string_vector_t),
                "::",
                stringify!(n_strings)
            )
        );
    }
    test_field_n_strings();
    fn test_field_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_string_vector_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_string_vector_t),
                "::",
                stringify!(alloc_size)
            )
        );
    }
    test_field_alloc_size();
    fn test_field_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_string_vector_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_string_vector_t),
                "::",
                stringify!(strings)
            )
        );
    }
    test_field_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_float_vector_t {
    pub length: i32,
    pub alloc_size: i32,
    pub arr: *const f32,
}
#[test]
fn bindgen_test_layout_exr_attr_float_vector_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_float_vector_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_float_vector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_float_vector_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_float_vector_t))
    );
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_float_vector_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_float_vector_t),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_float_vector_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_float_vector_t),
                "::",
                stringify!(alloc_size)
            )
        );
    }
    test_field_alloc_size();
    fn test_field_arr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_float_vector_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_float_vector_t),
                "::",
                stringify!(arr)
            )
        );
    }
    test_field_arr();
}
impl exr_perceptual_treatment_t {
    pub const EXR_PERCEPTUALLY_LOGARITHMIC: exr_perceptual_treatment_t =
        exr_perceptual_treatment_t(0);
}
impl exr_perceptual_treatment_t {
    pub const EXR_PERCEPTUALLY_LINEAR: exr_perceptual_treatment_t = exr_perceptual_treatment_t(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_perceptual_treatment_t(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_chlist_entry_t {
    pub name: exr_attr_string_t,
    pub pixel_type: exr_pixel_type_t,
    pub p_linear: u8,
    pub reserved: [u8; 3usize],
    pub x_sampling: i32,
    pub y_sampling: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_chlist_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_chlist_entry_t>(),
        32usize,
        concat!("Size of: ", stringify!(exr_attr_chlist_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_chlist_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_chlist_entry_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chlist_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chlist_entry_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_pixel_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chlist_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixel_type) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chlist_entry_t),
                "::",
                stringify!(pixel_type)
            )
        );
    }
    test_field_pixel_type();
    fn test_field_p_linear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chlist_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_linear) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chlist_entry_t),
                "::",
                stringify!(p_linear)
            )
        );
    }
    test_field_p_linear();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chlist_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            21usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chlist_entry_t),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_x_sampling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chlist_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x_sampling) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chlist_entry_t),
                "::",
                stringify!(x_sampling)
            )
        );
    }
    test_field_x_sampling();
    fn test_field_y_sampling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chlist_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y_sampling) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chlist_entry_t),
                "::",
                stringify!(y_sampling)
            )
        );
    }
    test_field_y_sampling();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_chlist_t {
    pub num_channels: ::std::os::raw::c_int,
    pub num_alloced: ::std::os::raw::c_int,
    pub entries: *const exr_attr_chlist_entry_t,
}
#[test]
fn bindgen_test_layout_exr_attr_chlist_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_chlist_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_chlist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_chlist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_chlist_t))
    );
    fn test_field_num_channels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chlist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_channels) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chlist_t),
                "::",
                stringify!(num_channels)
            )
        );
    }
    test_field_num_channels();
    fn test_field_num_alloced() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chlist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_alloced) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chlist_t),
                "::",
                stringify!(num_alloced)
            )
        );
    }
    test_field_num_alloced();
    fn test_field_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_chlist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_chlist_t),
                "::",
                stringify!(entries)
            )
        );
    }
    test_field_entries();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_preview_t {
    pub width: u32,
    pub height: u32,
    pub alloc_size: usize,
    pub rgba: *const u8,
}
#[test]
fn bindgen_test_layout_exr_attr_preview_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_preview_t>(),
        24usize,
        concat!("Size of: ", stringify!(exr_attr_preview_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_preview_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_preview_t))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_preview_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_preview_t),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_preview_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_preview_t),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_preview_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_preview_t),
                "::",
                stringify!(alloc_size)
            )
        );
    }
    test_field_alloc_size();
    fn test_field_rgba() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_preview_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rgba) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_preview_t),
                "::",
                stringify!(rgba)
            )
        );
    }
    test_field_rgba();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_opaquedata_t {
    pub size: i32,
    pub unpacked_size: i32,
    pub packed_alloc_size: i32,
    pub pad: [u8; 4usize],
    pub packed_data: *mut ::std::os::raw::c_void,
    pub unpacked_data: *mut ::std::os::raw::c_void,
    pub unpack_func_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            ctxt: exr_context_t,
            data: *const ::std::os::raw::c_void,
            attrsize: i32,
            outsize: *mut i32,
            outbuffer: *mut *mut ::std::os::raw::c_void,
        ) -> exr_result_t,
    >,
    pub pack_func_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            ctxt: exr_context_t,
            data: *const ::std::os::raw::c_void,
            datasize: i32,
            outsize: *mut i32,
            outbuffer: *mut ::std::os::raw::c_void,
        ) -> exr_result_t,
    >,
    pub destroy_unpacked_func_ptr: ::std::option::Option<
        unsafe extern "C" fn(ctxt: exr_context_t, data: *mut ::std::os::raw::c_void, attrsize: i32),
    >,
}
#[test]
fn bindgen_test_layout_exr_attr_opaquedata_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_opaquedata_t>(),
        56usize,
        concat!("Size of: ", stringify!(exr_attr_opaquedata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_opaquedata_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_opaquedata_t))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_opaquedata_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_opaquedata_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_unpacked_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_opaquedata_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unpacked_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_opaquedata_t),
                "::",
                stringify!(unpacked_size)
            )
        );
    }
    test_field_unpacked_size();
    fn test_field_packed_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_opaquedata_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_alloc_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_opaquedata_t),
                "::",
                stringify!(packed_alloc_size)
            )
        );
    }
    test_field_packed_alloc_size();
    fn test_field_pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_opaquedata_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_opaquedata_t),
                "::",
                stringify!(pad)
            )
        );
    }
    test_field_pad();
    fn test_field_packed_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_opaquedata_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_opaquedata_t),
                "::",
                stringify!(packed_data)
            )
        );
    }
    test_field_packed_data();
    fn test_field_unpacked_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_opaquedata_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unpacked_data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_opaquedata_t),
                "::",
                stringify!(unpacked_data)
            )
        );
    }
    test_field_unpacked_data();
    fn test_field_unpack_func_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_opaquedata_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unpack_func_ptr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_opaquedata_t),
                "::",
                stringify!(unpack_func_ptr)
            )
        );
    }
    test_field_unpack_func_ptr();
    fn test_field_pack_func_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_opaquedata_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pack_func_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_opaquedata_t),
                "::",
                stringify!(pack_func_ptr)
            )
        );
    }
    test_field_pack_func_ptr();
    fn test_field_destroy_unpacked_func_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attr_opaquedata_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy_unpacked_func_ptr) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attr_opaquedata_t),
                "::",
                stringify!(destroy_unpacked_func_ptr)
            )
        );
    }
    test_field_destroy_unpacked_func_ptr();
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_UNKNOWN: exr_attribute_type_t = exr_attribute_type_t(0);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_BOX2I: exr_attribute_type_t = exr_attribute_type_t(1);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_BOX2F: exr_attribute_type_t = exr_attribute_type_t(2);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_CHLIST: exr_attribute_type_t = exr_attribute_type_t(3);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_CHROMATICITIES: exr_attribute_type_t = exr_attribute_type_t(4);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_COMPRESSION: exr_attribute_type_t = exr_attribute_type_t(5);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_DOUBLE: exr_attribute_type_t = exr_attribute_type_t(6);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_ENVMAP: exr_attribute_type_t = exr_attribute_type_t(7);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_FLOAT: exr_attribute_type_t = exr_attribute_type_t(8);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_FLOAT_VECTOR: exr_attribute_type_t = exr_attribute_type_t(9);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_INT: exr_attribute_type_t = exr_attribute_type_t(10);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_KEYCODE: exr_attribute_type_t = exr_attribute_type_t(11);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_LINEORDER: exr_attribute_type_t = exr_attribute_type_t(12);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_M33F: exr_attribute_type_t = exr_attribute_type_t(13);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_M33D: exr_attribute_type_t = exr_attribute_type_t(14);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_M44F: exr_attribute_type_t = exr_attribute_type_t(15);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_M44D: exr_attribute_type_t = exr_attribute_type_t(16);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_PREVIEW: exr_attribute_type_t = exr_attribute_type_t(17);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_RATIONAL: exr_attribute_type_t = exr_attribute_type_t(18);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_STRING: exr_attribute_type_t = exr_attribute_type_t(19);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_STRING_VECTOR: exr_attribute_type_t = exr_attribute_type_t(20);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_TILEDESC: exr_attribute_type_t = exr_attribute_type_t(21);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_TIMECODE: exr_attribute_type_t = exr_attribute_type_t(22);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_V2I: exr_attribute_type_t = exr_attribute_type_t(23);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_V2F: exr_attribute_type_t = exr_attribute_type_t(24);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_V2D: exr_attribute_type_t = exr_attribute_type_t(25);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_V3I: exr_attribute_type_t = exr_attribute_type_t(26);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_V3F: exr_attribute_type_t = exr_attribute_type_t(27);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_V3D: exr_attribute_type_t = exr_attribute_type_t(28);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_OPAQUE: exr_attribute_type_t = exr_attribute_type_t(29);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_LAST_KNOWN_TYPE: exr_attribute_type_t = exr_attribute_type_t(30);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_attribute_type_t(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attribute_t {
    pub name: *const ::std::os::raw::c_char,
    pub type_name: *const ::std::os::raw::c_char,
    pub name_length: u8,
    pub type_name_length: u8,
    pub pad: [u8; 2usize],
    pub type_: exr_attribute_type_t,
    pub __bindgen_anon_1: exr_attribute_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union exr_attribute_t__bindgen_ty_1 {
    pub uc: u8,
    pub d: f64,
    pub f: f32,
    pub i: i32,
    pub box2i: *mut exr_attr_box2i_t,
    pub box2f: *mut exr_attr_box2f_t,
    pub chlist: *mut exr_attr_chlist_t,
    pub chromaticities: *mut exr_attr_chromaticities_t,
    pub keycode: *mut exr_attr_keycode_t,
    pub floatvector: *mut exr_attr_float_vector_t,
    pub m33f: *mut exr_attr_m33f_t,
    pub m33d: *mut exr_attr_m33d_t,
    pub m44f: *mut exr_attr_m44f_t,
    pub m44d: *mut exr_attr_m44d_t,
    pub preview: *mut exr_attr_preview_t,
    pub rational: *mut exr_attr_rational_t,
    pub string: *mut exr_attr_string_t,
    pub stringvector: *mut exr_attr_string_vector_t,
    pub tiledesc: *mut exr_attr_tiledesc_t,
    pub timecode: *mut exr_attr_timecode_t,
    pub v2i: *mut exr_attr_v2i_t,
    pub v2f: *mut exr_attr_v2f_t,
    pub v2d: *mut exr_attr_v2d_t,
    pub v3i: *mut exr_attr_v3i_t,
    pub v3f: *mut exr_attr_v3f_t,
    pub v3d: *mut exr_attr_v3d_t,
    pub opaque: *mut exr_attr_opaquedata_t,
    pub rawptr: *mut u8,
}
#[test]
fn bindgen_test_layout_exr_attribute_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attribute_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attribute_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attribute_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attribute_t__bindgen_ty_1))
    );
    fn test_field_uc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(uc)
            )
        );
    }
    test_field_uc();
    fn test_field_d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(d)
            )
        );
    }
    test_field_d();
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
    fn test_field_box2i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).box2i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(box2i)
            )
        );
    }
    test_field_box2i();
    fn test_field_box2f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).box2f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(box2f)
            )
        );
    }
    test_field_box2f();
    fn test_field_chlist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chlist) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(chlist)
            )
        );
    }
    test_field_chlist();
    fn test_field_chromaticities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chromaticities) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(chromaticities)
            )
        );
    }
    test_field_chromaticities();
    fn test_field_keycode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keycode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(keycode)
            )
        );
    }
    test_field_keycode();
    fn test_field_floatvector() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).floatvector) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(floatvector)
            )
        );
    }
    test_field_floatvector();
    fn test_field_m33f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m33f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(m33f)
            )
        );
    }
    test_field_m33f();
    fn test_field_m33d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m33d) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(m33d)
            )
        );
    }
    test_field_m33d();
    fn test_field_m44f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m44f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(m44f)
            )
        );
    }
    test_field_m44f();
    fn test_field_m44d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m44d) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(m44d)
            )
        );
    }
    test_field_m44d();
    fn test_field_preview() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preview) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(preview)
            )
        );
    }
    test_field_preview();
    fn test_field_rational() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rational) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(rational)
            )
        );
    }
    test_field_rational();
    fn test_field_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(string)
            )
        );
    }
    test_field_string();
    fn test_field_stringvector() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stringvector) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(stringvector)
            )
        );
    }
    test_field_stringvector();
    fn test_field_tiledesc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tiledesc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(tiledesc)
            )
        );
    }
    test_field_tiledesc();
    fn test_field_timecode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timecode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(timecode)
            )
        );
    }
    test_field_timecode();
    fn test_field_v2i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v2i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(v2i)
            )
        );
    }
    test_field_v2i();
    fn test_field_v2f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v2f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(v2f)
            )
        );
    }
    test_field_v2f();
    fn test_field_v2d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v2d) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(v2d)
            )
        );
    }
    test_field_v2d();
    fn test_field_v3i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v3i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(v3i)
            )
        );
    }
    test_field_v3i();
    fn test_field_v3f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v3f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(v3f)
            )
        );
    }
    test_field_v3f();
    fn test_field_v3d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v3d) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(v3d)
            )
        );
    }
    test_field_v3d();
    fn test_field_opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(opaque)
            )
        );
    }
    test_field_opaque();
    fn test_field_rawptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rawptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t__bindgen_ty_1),
                "::",
                stringify!(rawptr)
            )
        );
    }
    test_field_rawptr();
}
#[test]
fn bindgen_test_layout_exr_attribute_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attribute_t>(),
        32usize,
        concat!("Size of: ", stringify!(exr_attribute_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attribute_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attribute_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_type_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t),
                "::",
                stringify!(type_name)
            )
        );
    }
    test_field_type_name();
    fn test_field_name_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t),
                "::",
                stringify!(name_length)
            )
        );
    }
    test_field_name_length();
    fn test_field_type_name_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_name_length) as usize - ptr as usize
            },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t),
                "::",
                stringify!(type_name_length)
            )
        );
    }
    test_field_type_name_length();
    fn test_field_pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t),
                "::",
                stringify!(pad)
            )
        );
    }
    test_field_pad();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_attribute_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_attribute_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
}
extern "C" {
    pub fn exr_get_count(
        ctxt: exr_const_context_t,
        count: *mut ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_name(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_storage(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_storage_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_add_part(
        ctxt: exr_context_t,
        partname: *const ::std::os::raw::c_char,
        type_: exr_storage_t,
        new_index: *mut ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_tile_levels(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelsx: *mut i32,
        levelsy: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_tile_sizes(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        tilew: *mut i32,
        tileh: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_level_sizes(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        levw: *mut i32,
        levh: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_chunk_count(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_scanlines_per_chunk(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_chunk_unpacked_size(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut u64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_zip_compression_level(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        level: *mut ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_zip_compression_level(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_dwa_compression_level(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        level: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_dwa_compression_level(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        level: f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_attribute_count(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        count: *mut i32,
    ) -> exr_result_t;
}
impl exr_attr_list_access_mode {
    pub const EXR_ATTR_LIST_FILE_ORDER: exr_attr_list_access_mode = exr_attr_list_access_mode(0);
}
impl exr_attr_list_access_mode {
    pub const EXR_ATTR_LIST_SORTED_ORDER: exr_attr_list_access_mode = exr_attr_list_access_mode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_attr_list_access_mode(pub ::std::os::raw::c_int);
pub use self::exr_attr_list_access_mode as exr_attr_list_access_mode_t;
extern "C" {
    pub fn exr_get_attribute_by_index(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        mode: exr_attr_list_access_mode_t,
        idx: i32,
        outattr: *mut *const exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_attribute_by_name(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        outattr: *mut *const exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_attribute_list(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        mode: exr_attr_list_access_mode_t,
        count: *mut i32,
        outlist: *mut *const exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_declare_by_type(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        newattr: *mut *mut exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_declare(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: exr_attribute_type_t,
        newattr: *mut *mut exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_initialize_required_attr(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        displayWindow: *const exr_attr_box2i_t,
        dataWindow: *const exr_attr_box2i_t,
        pixelaspectratio: f32,
        screenWindowCenter: *const exr_attr_v2f_t,
        screenWindowWidth: f32,
        lineorder: exr_lineorder_t,
        ctype: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_initialize_required_attr_simple(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        width: i32,
        height: i32,
        ctype: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_copy_unset_attributes(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        source: exr_const_context_t,
        src_part_index: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_channels(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        chlist: *mut *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_add_channel(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        ptype: exr_pixel_type_t,
        percept: exr_perceptual_treatment_t,
        xsamp: i32,
        ysamp: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exr_set_channels(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        channels: *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_compression(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        compression: *mut exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_compression(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        ctype: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_data_window(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_data_window(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        dw: *const exr_attr_box2i_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exr_get_display_window(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_display_window(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        dw: *const exr_attr_box2i_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exr_get_lineorder(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_lineorder(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        lo: exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_pixel_aspect_ratio(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        par: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_pixel_aspect_ratio(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        par: f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_screen_window_center(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        wc: *mut exr_attr_v2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_screen_window_center(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        wc: *const exr_attr_v2f_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exr_get_screen_window_width(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_screen_window_width(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        ssw: f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_tile_descriptor(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        xsize: *mut u32,
        ysize: *mut u32,
        level: *mut exr_tile_level_mode_t,
        round: *mut exr_tile_round_mode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_tile_descriptor(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        x_size: u32,
        y_size: u32,
        level_mode: exr_tile_level_mode_t,
        round_mode: exr_tile_round_mode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_name(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        val: *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_version(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_version(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        val: i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_chunk_count(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        val: i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_box2i(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        outval: *mut exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_box2i(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: *const exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_box2f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        outval: *mut exr_attr_box2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_box2f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: *const exr_attr_box2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_channels(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        chlist: *mut *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_channels(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        channels: *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_chromaticities(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        chroma: *mut exr_attr_chromaticities_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_chromaticities(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        chroma: *const exr_attr_chromaticities_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_compression(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_compression(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        comp: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_double(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut f64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_double(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: f64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_envmap(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_envmap_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_envmap(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        emap: exr_envmap_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_float(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_float(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_float_vector(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        sz: *mut i32,
        out: *mut *const f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_float_vector(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        sz: i32,
        vals: *const f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_int(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_int(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_keycode(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_keycode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_keycode(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        kc: *const exr_attr_keycode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_lineorder(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_lineorder(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        lo: exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m33f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m33f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m33f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m33f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m33d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m33d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m33d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m33d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m44f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m44f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m44f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m44f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m44d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m44d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m44d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m44d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_preview(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_preview_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_preview(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        p: *const exr_attr_preview_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_rational(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_rational_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_rational(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        r: *const exr_attr_rational_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_string(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        length: *mut i32,
        out: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_string(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_string_vector(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        size: *mut i32,
        out: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_string_vector(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        size: i32,
        sv: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_tiledesc(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_tiledesc_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_tiledesc(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        td: *const exr_attr_tiledesc_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_timecode(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_timecode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_timecode(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        tc: *const exr_attr_timecode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v2i(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v2i(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v2f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v2f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v2d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v2d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v2d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v2d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v3i(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v3i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v3i(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v3i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v3f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v3f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v3f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v3f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v3d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v3d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v3d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v3d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_user(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: *mut *const ::std::os::raw::c_char,
        size: *mut i32,
        out: *mut *const ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_user(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        size: i32,
        out: *const ::std::os::raw::c_void,
    ) -> exr_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_chunk_info_t {
    pub idx: i32,
    pub start_x: i32,
    pub start_y: i32,
    pub height: i32,
    pub width: i32,
    pub level_x: u8,
    pub level_y: u8,
    pub type_: u8,
    pub compression: u8,
    pub data_offset: u64,
    pub packed_size: u64,
    pub unpacked_size: u64,
    pub sample_count_data_offset: u64,
    pub sample_count_table_size: u64,
}
#[test]
fn bindgen_test_layout_exr_chunk_info_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_chunk_info_t>(),
        64usize,
        concat!("Size of: ", stringify!(exr_chunk_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_chunk_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_chunk_info_t))
    );
    fn test_field_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(idx)
            )
        );
    }
    test_field_idx();
    fn test_field_start_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_x) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(start_x)
            )
        );
    }
    test_field_start_x();
    fn test_field_start_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(start_y)
            )
        );
    }
    test_field_start_y();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_level_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).level_x) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(level_x)
            )
        );
    }
    test_field_level_x();
    fn test_field_level_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).level_y) as usize - ptr as usize
            },
            21usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(level_y)
            )
        );
    }
    test_field_level_y();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_compression() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compression) as usize - ptr as usize
            },
            23usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(compression)
            )
        );
    }
    test_field_compression();
    fn test_field_data_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data_offset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(data_offset)
            )
        );
    }
    test_field_data_offset();
    fn test_field_packed_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(packed_size)
            )
        );
    }
    test_field_packed_size();
    fn test_field_unpacked_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unpacked_size) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(unpacked_size)
            )
        );
    }
    test_field_unpacked_size();
    fn test_field_sample_count_data_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sample_count_data_offset) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(sample_count_data_offset)
            )
        );
    }
    test_field_sample_count_data_offset();
    fn test_field_sample_count_table_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_chunk_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sample_count_table_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_chunk_info_t),
                "::",
                stringify!(sample_count_table_size)
            )
        );
    }
    test_field_sample_count_table_size();
}
extern "C" {
    pub fn exr_read_scanline_chunk_info(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_read_tile_chunk_info(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_read_chunk(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        packed_data: *mut ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_read_deep_chunk(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        packed_data: *mut ::std::os::raw::c_void,
        sample_data: *mut ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_scanline_chunk_info(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_tile_chunk_info(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_scanline_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_deep_scanline_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
        unpacked_size: u64,
        sample_data: *const ::std::os::raw::c_void,
        sample_data_size: u64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_tile_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_deep_tile_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
        unpacked_size: u64,
        sample_data: *const ::std::os::raw::c_void,
        sample_data_size: u64,
    ) -> exr_result_t;
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_PACKED: exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(0);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_UNPACKED: exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(1);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_COMPRESSED: exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(2);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_SCRATCH1: exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(3);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_SCRATCH2: exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(4);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_PACKED_SAMPLES: exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(5);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_SAMPLES: exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(6);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_transcoding_pipeline_buffer_id(pub ::std::os::raw::c_int);
pub use self::exr_transcoding_pipeline_buffer_id as exr_transcoding_pipeline_buffer_id_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_coding_channel_info_t {
    pub channel_name: *const ::std::os::raw::c_char,
    pub height: i32,
    pub width: i32,
    pub x_samples: i32,
    pub y_samples: i32,
    pub p_linear: u8,
    pub bytes_per_element: i8,
    pub data_type: u16,
    pub user_bytes_per_element: i16,
    pub user_data_type: u16,
    pub user_pixel_stride: i32,
    pub user_line_stride: i32,
    pub __bindgen_anon_1: exr_coding_channel_info_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union exr_coding_channel_info_t__bindgen_ty_1 {
    pub decode_to_ptr: *mut u8,
    pub encode_from_ptr: *const u8,
}
#[test]
fn bindgen_test_layout_exr_coding_channel_info_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_coding_channel_info_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_coding_channel_info_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1)
        )
    );
    fn test_field_decode_to_ptr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_coding_channel_info_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decode_to_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t__bindgen_ty_1),
                "::",
                stringify!(decode_to_ptr)
            )
        );
    }
    test_field_decode_to_ptr();
    fn test_field_encode_from_ptr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<exr_coding_channel_info_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encode_from_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t__bindgen_ty_1),
                "::",
                stringify!(encode_from_ptr)
            )
        );
    }
    test_field_encode_from_ptr();
}
#[test]
fn bindgen_test_layout_exr_coding_channel_info_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_coding_channel_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(exr_coding_channel_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_coding_channel_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_coding_channel_info_t))
    );
    fn test_field_channel_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(channel_name)
            )
        );
    }
    test_field_channel_name();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_x_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x_samples) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(x_samples)
            )
        );
    }
    test_field_x_samples();
    fn test_field_y_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y_samples) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(y_samples)
            )
        );
    }
    test_field_y_samples();
    fn test_field_p_linear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_linear) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(p_linear)
            )
        );
    }
    test_field_p_linear();
    fn test_field_bytes_per_element() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bytes_per_element) as usize - ptr as usize
            },
            25usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(bytes_per_element)
            )
        );
    }
    test_field_bytes_per_element();
    fn test_field_data_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize
            },
            26usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(data_type)
            )
        );
    }
    test_field_data_type();
    fn test_field_user_bytes_per_element() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_bytes_per_element) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(user_bytes_per_element)
            )
        );
    }
    test_field_user_bytes_per_element();
    fn test_field_user_data_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data_type) as usize - ptr as usize
            },
            30usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(user_data_type)
            )
        );
    }
    test_field_user_data_type();
    fn test_field_user_pixel_stride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_pixel_stride) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(user_pixel_stride)
            )
        );
    }
    test_field_user_pixel_stride();
    fn test_field_user_line_stride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exr_coding_channel_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_line_stride) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(exr_coding_channel_info_t),
                "::",
                stringify!(user_line_stride)
            )
        );
    }
    test_field_user_line_stride();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _exr_decode_pipeline {
    pub channels: *mut exr_coding_channel_info_t,
    pub channel_count: i16,
    pub decode_flags: u16,
    pub part_index: ::std::os::raw::c_int,
    pub context: exr_const_context_t,
    pub chunk: exr_chunk_info_t,
    pub decoding_user_data: *mut ::std::os::raw::c_void,
    pub packed_buffer: *mut ::std::os::raw::c_void,
    pub packed_alloc_size: usize,
    pub unpacked_buffer: *mut ::std::os::raw::c_void,
    pub unpacked_alloc_size: usize,
    pub packed_sample_count_table: *mut ::std::os::raw::c_void,
    pub packed_sample_count_alloc_size: usize,
    pub sample_count_table: *mut i32,
    pub sample_count_alloc_size: usize,
    pub scratch_buffer_1: *mut ::std::os::raw::c_void,
    pub scratch_alloc_size_1: usize,
    pub scratch_buffer_2: *mut ::std::os::raw::c_void,
    pub scratch_alloc_size_2: usize,
    pub alloc_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: exr_transcoding_pipeline_buffer_id_t,
            arg2: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: exr_transcoding_pipeline_buffer_id_t,
            arg2: *mut ::std::os::raw::c_void,
        ),
    >,
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(pipeline: *mut _exr_decode_pipeline) -> exr_result_t,
    >,
    pub decompress_fn: ::std::option::Option<
        unsafe extern "C" fn(pipeline: *mut _exr_decode_pipeline) -> exr_result_t,
    >,
    pub realloc_nonimage_data_fn: ::std::option::Option<
        unsafe extern "C" fn(pipeline: *mut _exr_decode_pipeline) -> exr_result_t,
    >,
    pub unpack_and_convert_fn: ::std::option::Option<
        unsafe extern "C" fn(pipeline: *mut _exr_decode_pipeline) -> exr_result_t,
    >,
    pub _quick_chan_store: [exr_coding_channel_info_t; 5usize],
}
#[test]
fn bindgen_test_layout__exr_decode_pipeline() {
    assert_eq!(
        ::std::mem::size_of::<_exr_decode_pipeline>(),
        480usize,
        concat!("Size of: ", stringify!(_exr_decode_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<_exr_decode_pipeline>(),
        8usize,
        concat!("Alignment of ", stringify!(_exr_decode_pipeline))
    );
    fn test_field_channels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(channels)
            )
        );
    }
    test_field_channels();
    fn test_field_channel_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel_count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(channel_count)
            )
        );
    }
    test_field_channel_count();
    fn test_field_decode_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decode_flags) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(decode_flags)
            )
        );
    }
    test_field_decode_flags();
    fn test_field_part_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).part_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(part_index)
            )
        );
    }
    test_field_part_index();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_chunk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(chunk)
            )
        );
    }
    test_field_chunk();
    fn test_field_decoding_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decoding_user_data) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(decoding_user_data)
            )
        );
    }
    test_field_decoding_user_data();
    fn test_field_packed_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_buffer) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(packed_buffer)
            )
        );
    }
    test_field_packed_buffer();
    fn test_field_packed_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_alloc_size) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(packed_alloc_size)
            )
        );
    }
    test_field_packed_alloc_size();
    fn test_field_unpacked_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unpacked_buffer) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(unpacked_buffer)
            )
        );
    }
    test_field_unpacked_buffer();
    fn test_field_unpacked_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unpacked_alloc_size) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(unpacked_alloc_size)
            )
        );
    }
    test_field_unpacked_alloc_size();
    fn test_field_packed_sample_count_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_sample_count_table) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(packed_sample_count_table)
            )
        );
    }
    test_field_packed_sample_count_table();
    fn test_field_packed_sample_count_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_sample_count_alloc_size) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(packed_sample_count_alloc_size)
            )
        );
    }
    test_field_packed_sample_count_alloc_size();
    fn test_field_sample_count_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sample_count_table) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(sample_count_table)
            )
        );
    }
    test_field_sample_count_table();
    fn test_field_sample_count_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sample_count_alloc_size) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(sample_count_alloc_size)
            )
        );
    }
    test_field_sample_count_alloc_size();
    fn test_field_scratch_buffer_1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratch_buffer_1) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(scratch_buffer_1)
            )
        );
    }
    test_field_scratch_buffer_1();
    fn test_field_scratch_alloc_size_1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratch_alloc_size_1) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(scratch_alloc_size_1)
            )
        );
    }
    test_field_scratch_alloc_size_1();
    fn test_field_scratch_buffer_2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratch_buffer_2) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(scratch_buffer_2)
            )
        );
    }
    test_field_scratch_buffer_2();
    fn test_field_scratch_alloc_size_2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratch_alloc_size_2) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(scratch_alloc_size_2)
            )
        );
    }
    test_field_scratch_alloc_size_2();
    fn test_field_alloc_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alloc_fn) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(alloc_fn)
            )
        );
    }
    test_field_alloc_fn();
    fn test_field_free_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_fn) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(free_fn)
            )
        );
    }
    test_field_free_fn();
    fn test_field_read_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_fn) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(read_fn)
            )
        );
    }
    test_field_read_fn();
    fn test_field_decompress_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decompress_fn) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(decompress_fn)
            )
        );
    }
    test_field_decompress_fn();
    fn test_field_realloc_nonimage_data_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).realloc_nonimage_data_fn) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(realloc_nonimage_data_fn)
            )
        );
    }
    test_field_realloc_nonimage_data_fn();
    fn test_field_unpack_and_convert_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unpack_and_convert_fn) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(unpack_and_convert_fn)
            )
        );
    }
    test_field_unpack_and_convert_fn();
    fn test_field__quick_chan_store() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_decode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._quick_chan_store) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_decode_pipeline),
                "::",
                stringify!(_quick_chan_store)
            )
        );
    }
    test_field__quick_chan_store();
}
pub type exr_decode_pipeline_t = _exr_decode_pipeline;
extern "C" {
    pub fn exr_decoding_initialize(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_decoding_choose_default_routines(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_decoding_update(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_decoding_run(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_decoding_destroy(
        ctxt: exr_const_context_t,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _exr_encode_pipeline {
    pub channels: *mut exr_coding_channel_info_t,
    pub channel_count: i16,
    pub encode_flags: u16,
    pub part_index: ::std::os::raw::c_int,
    pub context: exr_const_context_t,
    pub chunk: exr_chunk_info_t,
    pub encoding_user_data: *mut ::std::os::raw::c_void,
    pub packed_buffer: *mut ::std::os::raw::c_void,
    pub packed_bytes: u64,
    pub packed_alloc_size: usize,
    pub sample_count_table: *mut i32,
    pub sample_count_alloc_size: usize,
    pub packed_sample_count_table: *mut ::std::os::raw::c_void,
    pub packed_sample_count_bytes: usize,
    pub packed_sample_count_alloc_size: usize,
    pub compressed_buffer: *mut ::std::os::raw::c_void,
    pub compressed_bytes: usize,
    pub compressed_alloc_size: usize,
    pub scratch_buffer_1: *mut ::std::os::raw::c_void,
    pub scratch_alloc_size_1: usize,
    pub scratch_buffer_2: *mut ::std::os::raw::c_void,
    pub scratch_alloc_size_2: usize,
    pub alloc_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: exr_transcoding_pipeline_buffer_id_t,
            arg2: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: exr_transcoding_pipeline_buffer_id_t,
            arg2: *mut ::std::os::raw::c_void,
        ),
    >,
    pub convert_and_pack_fn: ::std::option::Option<
        unsafe extern "C" fn(pipeline: *mut _exr_encode_pipeline) -> exr_result_t,
    >,
    pub compress_fn: ::std::option::Option<
        unsafe extern "C" fn(pipeline: *mut _exr_encode_pipeline) -> exr_result_t,
    >,
    pub yield_until_ready_fn: ::std::option::Option<
        unsafe extern "C" fn(pipeline: *mut _exr_encode_pipeline) -> exr_result_t,
    >,
    pub write_fn: ::std::option::Option<
        unsafe extern "C" fn(pipeline: *mut _exr_encode_pipeline) -> exr_result_t,
    >,
    pub _quick_chan_store: [exr_coding_channel_info_t; 5usize],
}
#[test]
fn bindgen_test_layout__exr_encode_pipeline() {
    assert_eq!(
        ::std::mem::size_of::<_exr_encode_pipeline>(),
        504usize,
        concat!("Size of: ", stringify!(_exr_encode_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<_exr_encode_pipeline>(),
        8usize,
        concat!("Alignment of ", stringify!(_exr_encode_pipeline))
    );
    fn test_field_channels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(channels)
            )
        );
    }
    test_field_channels();
    fn test_field_channel_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel_count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(channel_count)
            )
        );
    }
    test_field_channel_count();
    fn test_field_encode_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encode_flags) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(encode_flags)
            )
        );
    }
    test_field_encode_flags();
    fn test_field_part_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).part_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(part_index)
            )
        );
    }
    test_field_part_index();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_chunk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(chunk)
            )
        );
    }
    test_field_chunk();
    fn test_field_encoding_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encoding_user_data) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(encoding_user_data)
            )
        );
    }
    test_field_encoding_user_data();
    fn test_field_packed_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_buffer) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(packed_buffer)
            )
        );
    }
    test_field_packed_buffer();
    fn test_field_packed_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_bytes) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(packed_bytes)
            )
        );
    }
    test_field_packed_bytes();
    fn test_field_packed_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_alloc_size) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(packed_alloc_size)
            )
        );
    }
    test_field_packed_alloc_size();
    fn test_field_sample_count_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sample_count_table) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(sample_count_table)
            )
        );
    }
    test_field_sample_count_table();
    fn test_field_sample_count_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sample_count_alloc_size) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(sample_count_alloc_size)
            )
        );
    }
    test_field_sample_count_alloc_size();
    fn test_field_packed_sample_count_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_sample_count_table) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(packed_sample_count_table)
            )
        );
    }
    test_field_packed_sample_count_table();
    fn test_field_packed_sample_count_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_sample_count_bytes) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(packed_sample_count_bytes)
            )
        );
    }
    test_field_packed_sample_count_bytes();
    fn test_field_packed_sample_count_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packed_sample_count_alloc_size) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(packed_sample_count_alloc_size)
            )
        );
    }
    test_field_packed_sample_count_alloc_size();
    fn test_field_compressed_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressed_buffer) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(compressed_buffer)
            )
        );
    }
    test_field_compressed_buffer();
    fn test_field_compressed_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressed_bytes) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(compressed_bytes)
            )
        );
    }
    test_field_compressed_bytes();
    fn test_field_compressed_alloc_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressed_alloc_size) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(compressed_alloc_size)
            )
        );
    }
    test_field_compressed_alloc_size();
    fn test_field_scratch_buffer_1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratch_buffer_1) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(scratch_buffer_1)
            )
        );
    }
    test_field_scratch_buffer_1();
    fn test_field_scratch_alloc_size_1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratch_alloc_size_1) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(scratch_alloc_size_1)
            )
        );
    }
    test_field_scratch_alloc_size_1();
    fn test_field_scratch_buffer_2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratch_buffer_2) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(scratch_buffer_2)
            )
        );
    }
    test_field_scratch_buffer_2();
    fn test_field_scratch_alloc_size_2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratch_alloc_size_2) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(scratch_alloc_size_2)
            )
        );
    }
    test_field_scratch_alloc_size_2();
    fn test_field_alloc_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alloc_fn) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(alloc_fn)
            )
        );
    }
    test_field_alloc_fn();
    fn test_field_free_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_fn) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(free_fn)
            )
        );
    }
    test_field_free_fn();
    fn test_field_convert_and_pack_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).convert_and_pack_fn) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(convert_and_pack_fn)
            )
        );
    }
    test_field_convert_and_pack_fn();
    fn test_field_compress_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compress_fn) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(compress_fn)
            )
        );
    }
    test_field_compress_fn();
    fn test_field_yield_until_ready_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).yield_until_ready_fn) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(yield_until_ready_fn)
            )
        );
    }
    test_field_yield_until_ready_fn();
    fn test_field_write_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_fn) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(write_fn)
            )
        );
    }
    test_field_write_fn();
    fn test_field__quick_chan_store() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_exr_encode_pipeline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._quick_chan_store) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_exr_encode_pipeline),
                "::",
                stringify!(_quick_chan_store)
            )
        );
    }
    test_field__quick_chan_store();
}
pub type exr_encode_pipeline_t = _exr_encode_pipeline;
extern "C" {
    pub fn exr_encoding_initialize(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_encoding_choose_default_routines(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_encoding_update(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_encoding_run(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_encoding_destroy(
        ctxt: exr_const_context_t,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_print_context_info(
        c: exr_const_context_t,
        verbose: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
