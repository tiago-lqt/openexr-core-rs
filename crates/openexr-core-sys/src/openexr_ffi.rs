/* automatically generated by rust-bindgen 0.69.4 */

use crate::*;

pub const OPENEXR_VERSION_MAJOR: u32 = 3;
pub const OPENEXR_VERSION_MINOR: u32 = 4;
pub const OPENEXR_VERSION_PATCH: u32 = 0;
pub const OPENEXR_VERSION_STRING: &[u8; 6] = b"3.4.0\0";
pub const OPENEXR_VERSION_RELEASE_TYPE: &[u8; 31] =
    b"@OPENEXR_VERSION_RELEASE_TYPE@\0";
pub const OPENEXR_VERSION_EXTRA: &[u8; 31] =
    b"@OPENEXR_VERSION_RELEASE_TYPE@\0";
pub const OPENEXR_VERSION_HEX: u32 = 50593792;
pub const EXR_CONTEXT_FLAG_STRICT_HEADER: u32 = 1;
pub const EXR_CONTEXT_FLAG_SILENT_HEADER_PARSE: u32 = 2;
pub const EXR_CONTEXT_FLAG_DISABLE_CHUNK_RECONSTRUCTION: u32 = 4;
pub const EXR_CONTEXT_FLAG_WRITE_LEGACY_HEADER: u32 = 8;
extern "C" {
    #[doc = " @brief Retrieve the current library version. The @p extra string is for\n custom installs, and is a static string, do not free the returned\n pointer."]
    pub fn exr_get_library_version(
        maj: *mut ::std::os::raw::c_int,
        min: *mut ::std::os::raw::c_int,
        patch: *mut ::std::os::raw::c_int,
        extra: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Limit the size of image allowed to be parsed or created by\n the library.\n\n This is used as a safety check against corrupt files, but can also\n serve to avoid potential issues on machines which have very\n constrained RAM.\n\n These values are among the only globals in the core layer of\n OpenEXR. The intended use is for applications to define a global\n default, which will be combined with the values provided to the\n individual context creation routine. The values are used to check\n against parsed header values. This adds some level of safety from\n memory overruns where a corrupt file given to the system may cause\n a large allocation to happen, enabling buffer overruns or other\n potential security issue.\n\n These global values are combined with the values in\n \\ref exr_context_initializer_t using the following rules:\n\n 1. negative values are ignored.\n\n 2. if either value has a positive (non-zero) value, and the other\n    has 0, the positive value is preferred.\n\n 3. If both are positive (non-zero), the minimum value is used.\n\n 4. If both values are 0, this disables the constrained size checks.\n\n This function does not fail."]
    pub fn exr_set_default_maximum_image_size(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieve the global default maximum image size.\n\n This function does not fail."]
    pub fn exr_get_default_maximum_image_size(
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Limit the size of an image tile allowed to be parsed or\n created by the library.\n\n Similar to image size, this places constraints on the maximum tile\n size as a safety check against bad file data\n\n This is used as a safety check against corrupt files, but can also\n serve to avoid potential issues on machines which have very\n constrained RAM\n\n These values are among the only globals in the core layer of\n OpenEXR. The intended use is for applications to define a global\n default, which will be combined with the values provided to the\n individual context creation routine. The values are used to check\n against parsed header values. This adds some level of safety from\n memory overruns where a corrupt file given to the system may cause\n a large allocation to happen, enabling buffer overruns or other\n potential security issue.\n\n These global values are combined with the values in\n \\ref exr_context_initializer_t using the following rules:\n\n 1. negative values are ignored.\n\n 2. if either value has a positive (non-zero) value, and the other\n    has 0, the positive value is preferred.\n\n 3. If both are positive (non-zero), the minimum value is used.\n\n 4. If both values are 0, this disables the constrained size checks.\n\n This function does not fail."]
    pub fn exr_set_default_maximum_tile_size(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieve the global maximum tile size.\n\n This function does not fail."]
    pub fn exr_get_default_maximum_tile_size(
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Assigns a default zip compression level.\n\n This value may be controlled separately on each part, but this\n global control determines the initial value."]
    pub fn exr_set_default_zip_compression_level(l: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Retrieve the global default zip compression value"]
    pub fn exr_get_default_zip_compression_level(l: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Assigns a default DWA compression quality level.\n\n This value may be controlled separately on each part, but this\n global control determines the initial value."]
    pub fn exr_set_default_dwa_compression_quality(q: f32);
}
extern "C" {
    #[doc = " @brief Retrieve the global default dwa compression quality"]
    pub fn exr_get_default_dwa_compression_quality(q: *mut f32);
}
#[doc = " @brief Function pointer used to hold a malloc-like routine.\n\n Providing these to a context will override what memory is used to\n allocate the context itself, as well as any allocations which\n happen during processing of a file or stream. This can be used by\n systems which provide rich malloc tracking routines to override the\n internal allocations performed by the library.\n\n This function is expected to allocate and return a new memory\n handle, or `NULL` if allocation failed (which the library will then\n handle and return an out-of-memory error).\n\n If one is provided, both should be provided.\n @sa exr_memory_free_func_t"]
pub type exr_memory_allocation_func_t = ::std::option::Option<
    unsafe extern "C" fn(bytes: usize) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @brief Function pointer used to hold a free-like routine.\n\n Providing these to a context will override what memory is used to\n allocate the context itself, as well as any allocations which\n happen during processing of a file or stream. This can be used by\n systems which provide rich malloc tracking routines to override the\n internal allocations performed by the library.\n\n This function is expected to return memory to the system, ala free\n from the C library.\n\n If providing one, probably need to provide both routines.\n @sa exr_memory_allocation_func_t"]
pub type exr_memory_free_func_t = ::std::option::Option<
    unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @brief Allow the user to override default allocator used internal\n allocations necessary for files, attributes, and other temporary\n memory.\n\n These routines may be overridden when creating a specific context,\n however this provides global defaults such that the default can be\n applied.\n\n If either pointer is 0, the appropriate malloc/free routine will be\n substituted.\n\n This function does not fail."]
    pub fn exr_set_default_memory_routines(
        alloc_func: exr_memory_allocation_func_t,
        free_func: exr_memory_free_func_t,
    );
}
#[repr(i32)]
#[doc = " Error codes that may be returned by various functions."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum exr_error_code_t {
    EXR_ERR_SUCCESS = 0,
    EXR_ERR_OUT_OF_MEMORY = 1,
    EXR_ERR_MISSING_CONTEXT_ARG = 2,
    EXR_ERR_INVALID_ARGUMENT = 3,
    EXR_ERR_ARGUMENT_OUT_OF_RANGE = 4,
    EXR_ERR_FILE_ACCESS = 5,
    EXR_ERR_FILE_BAD_HEADER = 6,
    EXR_ERR_NOT_OPEN_READ = 7,
    EXR_ERR_NOT_OPEN_WRITE = 8,
    EXR_ERR_HEADER_NOT_WRITTEN = 9,
    EXR_ERR_READ_IO = 10,
    EXR_ERR_WRITE_IO = 11,
    EXR_ERR_NAME_TOO_LONG = 12,
    EXR_ERR_MISSING_REQ_ATTR = 13,
    EXR_ERR_INVALID_ATTR = 14,
    EXR_ERR_NO_ATTR_BY_NAME = 15,
    EXR_ERR_ATTR_TYPE_MISMATCH = 16,
    EXR_ERR_ATTR_SIZE_MISMATCH = 17,
    EXR_ERR_SCAN_TILE_MIXEDAPI = 18,
    EXR_ERR_TILE_SCAN_MIXEDAPI = 19,
    EXR_ERR_MODIFY_SIZE_CHANGE = 20,
    EXR_ERR_ALREADY_WROTE_ATTRS = 21,
    EXR_ERR_BAD_CHUNK_LEADER = 22,
    EXR_ERR_CORRUPT_CHUNK = 23,
    EXR_ERR_INCOMPLETE_CHUNK_TABLE = 24,
    EXR_ERR_INCORRECT_PART = 25,
    EXR_ERR_INCORRECT_CHUNK = 26,
    EXR_ERR_USE_SCAN_DEEP_WRITE = 27,
    EXR_ERR_USE_TILE_DEEP_WRITE = 28,
    EXR_ERR_USE_SCAN_NONDEEP_WRITE = 29,
    EXR_ERR_USE_TILE_NONDEEP_WRITE = 30,
    EXR_ERR_INVALID_SAMPLE_DATA = 31,
    EXR_ERR_FEATURE_NOT_IMPLEMENTED = 32,
    EXR_ERR_UNKNOWN = 33,
}
#[doc = " Return type for all functions."]
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct exr_result_t(pub i32);
extern "C" {
    #[doc = " @brief Return a static string corresponding to the specified error code.\n\n The string should not be freed (it is compiled into the binary)."]
    pub fn exr_get_default_error_message(
        code: exr_result_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return a static string corresponding to the specified error code.\n\n The string should not be freed (it is compiled into the binary)."]
    pub fn exr_get_error_code_as_string(
        code: exr_result_t,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _priv_exr_context_t {
    _unused: [u8; 0],
}
#[doc = " Opaque context handle\n\n The implementation of this is partly opaque to provide better\n version portability, and all accesses to relevant data should\n happen using provided functions. This handle serves as a container\n and identifier for all the metadata and parts associated with a\n file and/or stream."]
pub type exr_context_t = *mut _priv_exr_context_t;
pub type exr_const_context_t = *const _priv_exr_context_t;
#[doc = " @brief Stream error notifier\n\n  This function pointer is provided to the stream functions by the\n  library such that they can provide a nice error message to the\n  user during stream operations."]
pub type exr_stream_error_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        code: exr_result_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> exr_result_t,
>;
#[doc = " @brief Error callback function\n\n  Because a file can be read from using many threads at once, it is\n  difficult to store an error message for later retrieval. As such,\n  when a file is constructed, a callback function can be provided\n  which delivers an error message for the calling application to\n  handle. This will then be delivered on the same thread causing the\n  error."]
pub type exr_error_handler_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        code: exr_result_t,
        msg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Destroy custom stream function pointer\n\n  Generic callback to clean up user data for custom streams.\n  This is called when the file is closed and expected not to\n  error.\n\n  @param failed Indicates the write operation failed, the\n                implementor may wish to cleanup temporary files\n  @param ctxt The context\n  @param userdata The userdata"]
pub type exr_destroy_stream_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
        failed: ::std::os::raw::c_int,
    ),
>;
#[doc = " Query stream size function pointer\n\n Used to query the size of the file, or amount of data representing\n the openexr file in the data stream.\n\n This is used to validate requests against the file. If the size is\n unavailable, return -1, which will disable these validation steps\n for this file, although appropriate memory safeguards must be in\n place in the calling application."]
pub type exr_query_size_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
    ) -> i64,
>;
#[doc = " @brief Read custom function pointer\n\n Used to read data from a custom output. Expects similar semantics to\n pread or ReadFile with overlapped data under win32.\n\n It is required that this provides thread-safe concurrent access to\n the same file. If the stream/input layer you are providing does\n not have this guarantee, your are responsible for providing\n appropriate serialization of requests.\n\n A file should be expected to be accessed in the following pattern:\n  - upon open, the header and part information attributes will be read\n  - upon the first image read request, the offset tables will be read\n    multiple threads accessing this concurrently may actually read\n    these values at the same time\n  - chunks can then be read in any order as preferred by the\n    application\n\n While this should mean that the header will be read in 'stream'\n order (no seeks required), no guarantee is made beyond that to\n retrieve image/deep data in order. So if the backing file is\n truly a stream, it is up to the provider to implement appropriate\n caching of data to give the appearance of being able to seek/read\n atomically.\n\n TODO: This does not handle the ability to mmap a file and get to\n zero copy"]
pub type exr_read_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
        sz: u64,
        offset: u64,
        error_cb: exr_stream_error_func_ptr_t,
    ) -> i64,
>;
#[doc = " Write custom function pointer\n\n  Used to write data to a custom output. Expects similar semantics to\n  pwrite or WriteFile with overlapped data under win32.\n\n  It is required that this provides thread-safe concurrent access to\n  the same file. While it is unlikely that multiple threads will\n  be used to write data for compressed forms, it is possible.\n\n  A file should be expected to be accessed in the following pattern:\n  - upon open, the header and part information attributes is constructed.\n\n  - when the write_header routine is called, the header becomes immutable\n    and is written to the file. This computes the space to store the chunk\n    offsets, but does not yet write the values.\n\n  - Image chunks are written to the file, and appear in the order\n    they are written, not in the ordering that is required by the\n    chunk offset table (unless written in that order). This may vary\n    slightly if the size of the chunks is not directly known and\n    tight packing of data is necessary.\n\n  - at file close, the chunk offset tables are written to the file."]
pub type exr_write_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_void,
        sz: u64,
        offset: u64,
        error_cb: exr_stream_error_func_ptr_t,
    ) -> i64,
>;
#[doc = " @brief Struct used to pass function pointers into the context\n initialization routines.\n\n This partly exists to avoid the chicken and egg issue around\n creating the storage needed for the context on systems which want\n to override the malloc/free routines.\n\n However, it also serves to make a tidier/simpler set of functions\n to create and start processing exr files.\n\n The size member is required for version portability.\n\n It can be initialized using \\c EXR_DEFAULT_CONTEXT_INITIALIZER.\n\n \\code{.c}\n exr_context_initializer_t myctxtinit = DEFAULT_CONTEXT_INITIALIZER;\n myctxtinit.error_cb = &my_super_cool_error_callback_function;\n ...\n \\endcode\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _exr_context_initializer_v3 {
    #[doc = " @brief Size member to tag initializer for version stability.\n\n This should be initialized to the size of the current\n structure. This allows EXR to add functions or other\n initializers in the future, and retain version compatibility"]
    pub size: usize,
    #[doc = " @brief Error callback function pointer\n\n The error callback is allowed to be `NULL`, and will use a\n default print which outputs to \\c stderr.\n\n @sa exr_error_handler_cb_t"]
    pub error_handler_fn: exr_error_handler_cb_t,
    #[doc = " Custom allocator, if `NULL`, will use malloc. @sa exr_memory_allocation_func_t"]
    pub alloc_fn: exr_memory_allocation_func_t,
    #[doc = " Custom deallocator, if `NULL`, will use free. @sa exr_memory_free_func_t"]
    pub free_fn: exr_memory_free_func_t,
    #[doc = " Blind data passed to custom read, size, write, destroy\n functions below. Up to user to manage this pointer."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " @brief Custom read routine.\n\n This is only used during read or update contexts. If this is\n provided, it is expected that the caller has previously made\n the stream available, and placed whatever stream/file data\n into \\c user_data above.\n\n If this is `NULL`, and the context requested is for reading an\n exr file, an internal implementation is provided for reading\n from normal filesystem files, and the filename provided is\n attempted to be opened as such.\n\n Expected to be `NULL` for a write-only operation, but is ignored\n if it is provided.\n\n For update contexts, both read and write functions must be\n provided if either is.\n\n @sa exr_read_func_ptr_t"]
    pub read_fn: exr_read_func_ptr_t,
    #[doc = " @brief Custom size query routine.\n\n Used to provide validation when reading header values. If this\n is not provided, but a custom read routine is provided, this\n will disable some of the validation checks when parsing the\n image header.\n\n Expected to be `NULL` for a write-only operation, but is ignored\n if it is provided.\n\n @sa exr_query_size_func_ptr_t"]
    pub size_fn: exr_query_size_func_ptr_t,
    #[doc = " @brief Custom write routine.\n\n This is only used during write or update contexts. If this is\n provided, it is expected that the caller has previously made\n the stream available, and placed whatever stream/file data\n into \\c user_data above.\n\n If this is `NULL`, and the context requested is for writing an\n exr file, an internal implementation is provided for reading\n from normal filesystem files, and the filename provided is\n attempted to be opened as such.\n\n For update contexts, both read and write functions must be\n provided if either is.\n\n @sa exr_write_func_ptr_t"]
    pub write_fn: exr_write_func_ptr_t,
    #[doc = " @brief Optional function to destroy the user data block of a custom stream.\n\n Allows one to free any user allocated data, and close any handles.\n\n @sa exr_destroy_stream_func_ptr_t"]
    pub destroy_fn: exr_destroy_stream_func_ptr_t,
    #[doc = " Initialize a field specifying what the maximum image width\n allowed by the context is. See exr_set_default_maximum_image_size() to\n understand how this interacts with global defaults."]
    pub max_image_width: ::std::os::raw::c_int,
    #[doc = " Initialize a field specifying what the maximum image height\n allowed by the context is. See exr_set_default_maximum_image_size() to\n understand how this interacts with global defaults."]
    pub max_image_height: ::std::os::raw::c_int,
    #[doc = " Initialize a field specifying what the maximum tile width\n allowed by the context is. See exr_set_default_maximum_tile_size() to\n understand how this interacts with global defaults."]
    pub max_tile_width: ::std::os::raw::c_int,
    #[doc = " Initialize a field specifying what the maximum tile height\n allowed by the context is. See exr_set_default_maximum_tile_size() to\n understand how this interacts with global defaults."]
    pub max_tile_height: ::std::os::raw::c_int,
    #[doc = " Initialize a field specifying what the default zip compression level should be\n for this context. See exr_set_default_zip_compresion_level() to\n set it for all contexts."]
    pub zip_level: ::std::os::raw::c_int,
    #[doc = " Initialize the default dwa compression quality. See\n exr_set_default_dwa_compression_quality() to set the default\n for all contexts."]
    pub dwa_quality: f32,
    #[doc = " Initialize with a bitwise or of the various context flags"]
    pub flags: ::std::os::raw::c_int,
    pub pad: [u8; 4usize],
}
#[test]
fn bindgen_test_layout__exr_context_initializer_v3() {
    const UNINIT: ::std::mem::MaybeUninit<_exr_context_initializer_v3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_exr_context_initializer_v3>(),
        104usize,
        concat!("Size of: ", stringify!(_exr_context_initializer_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<_exr_context_initializer_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(_exr_context_initializer_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).error_handler_fn) as usize
                - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(error_handler_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).alloc_fn) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(alloc_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_fn) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_fn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_fn) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(size_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).write_fn) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(write_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).destroy_fn) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(destroy_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_image_width) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(max_image_width)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_image_height) as usize
                - ptr as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(max_image_height)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_tile_width) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(max_tile_width)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_tile_height) as usize - ptr as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(max_tile_height)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).zip_level) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(zip_level)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dwa_quality) as usize - ptr as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(dwa_quality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer_v3),
            "::",
            stringify!(pad)
        )
    );
}
#[doc = " @brief Struct used to pass function pointers into the context\n initialization routines.\n\n This partly exists to avoid the chicken and egg issue around\n creating the storage needed for the context on systems which want\n to override the malloc/free routines.\n\n However, it also serves to make a tidier/simpler set of functions\n to create and start processing exr files.\n\n The size member is required for version portability.\n\n It can be initialized using \\c EXR_DEFAULT_CONTEXT_INITIALIZER.\n\n \\code{.c}\n exr_context_initializer_t myctxtinit = DEFAULT_CONTEXT_INITIALIZER;\n myctxtinit.error_cb = &my_super_cool_error_callback_function;\n ...\n \\endcode\n"]
pub type exr_context_initializer_t = _exr_context_initializer_v3;
extern "C" {
    #[doc = " @brief Check the magic number of the file and report\n `EXR_ERR_SUCCESS` if the file appears to be a valid file (or at least\n has the correct magic number and can be read)."]
    pub fn exr_test_file_header(
        filename: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Close and free any internally allocated memory,\n calling any provided destroy function for custom streams.\n\n If the file was opened for write, first save the chunk offsets\n or any other unwritten data."]
    pub fn exr_finish(ctxt: *mut exr_context_t) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Create and initialize a read-only exr read context.\n\n If a custom read function is provided, the filename is for\n informational purposes only, the system assumes the user has\n previously opened a stream, file, or whatever and placed relevant\n data in userdata to access that.\n\n One notable attribute of the context is that once it has been\n created and returned a successful code, it has parsed all the\n header data. This is done as one step such that it is easier to\n provide a safe context for multiple threads to request data from\n the same context concurrently.\n\n Once finished reading data, use exr_finish() to clean up\n the context.\n\n If you have custom I/O requirements, see the initializer context\n documentation \\ref exr_context_initializer_t. The @p ctxtdata parameter\n is optional, if `NULL`, default values will be used."]
    pub fn exr_start_read(
        ctxt: *mut exr_context_t,
        filename: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
impl exr_default_write_mode {
    pub const EXR_WRITE_FILE_DIRECTLY: exr_default_write_mode =
        exr_default_write_mode(0);
}
impl exr_default_write_mode {
    pub const EXR_INTERMEDIATE_TEMP_FILE: exr_default_write_mode =
        exr_default_write_mode(1);
}
#[repr(transparent)]
#[doc = " @brief Enum describing how default files are handled during write."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_default_write_mode(pub ::std::os::raw::c_int);
#[doc = " @brief Enum describing how default files are handled during write."]
pub use self::exr_default_write_mode as exr_default_write_mode_t;
extern "C" {
    #[doc = " @brief Create and initialize a write-only context.\n\n If a custom write function is provided, the filename is for\n informational purposes only, and the @p default_mode parameter will be\n ignored. As such, the system assumes the user has previously opened\n a stream, file, or whatever and placed relevant data in userdata to\n access that.\n\n Multi-Threading: To avoid issues with creating multi-part EXR\n files, the library approaches writing as a multi-step process, so\n the same concurrent guarantees can not be made for writing a\n file. The steps are:\n\n 1. Context creation (this function)\n\n 2. Part definition (required attributes and additional metadata)\n\n 3. Transition to writing data (this \"commits\" the part definitions,\n any changes requested after will result in an error)\n\n 4. Write part data in sequential order of parts (part<sub>0</sub>\n -> part<sub>N-1</sub>).\n\n 5. Within each part, multiple threads can be encoding and writing\n data concurrently. For some EXR part definitions, this may be able\n to write data concurrently when it can predict the chunk sizes, or\n data is allowed to be padded. For others, it may need to\n temporarily cache chunks until the data is received to flush in\n order. The concurrency around this is handled by the library\n\n 6. Once finished writing data, use exr_finish() to clean\n up the context, which will flush any unwritten data such as the\n final chunk offset tables, and handle the temporary file flags.\n\n If you have custom I/O requirements, see the initializer context\n documentation \\ref exr_context_initializer_t. The @p ctxtdata\n parameter is optional, if `NULL`, default values will be used."]
    pub fn exr_start_write(
        ctxt: *mut exr_context_t,
        filename: *const ::std::os::raw::c_char,
        default_mode: exr_default_write_mode_t,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Create a new context for updating an exr file in place.\n\n This is a custom mode that allows one to modify the value of a\n metadata entry, although not to change the size of the header, or\n any of the image data.\n\n If you have custom I/O requirements, see the initializer context\n documentation \\ref exr_context_initializer_t. The @p ctxtdata parameter\n is optional, if `NULL`, default values will be used."]
    pub fn exr_start_inplace_header_update(
        ctxt: *mut exr_context_t,
        filename: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Create a new context for temporary use in memory.\n\n This is a custom mode that does not supporting writing actual image\n data, but one can create one of these, manipulate attributes,\n define additional parts, run validation, etc. without any\n requirement of actual file i/o.\n\n Note that this creates an defines an initial part for use, so one\n can immediately start definining attributes into part index 0.\n\n See the initializer context documentation \\ref\n exr_context_initializer_t to be able to provide allocation\n overrides or other controls. The @p ctxtdata parameter is optional,\n if `NULL`, default values will be used."]
    pub fn exr_start_temporary_context(
        ctxt: *mut exr_context_t,
        context_name: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the file name the context is for as provided\n during the start routine.\n\n Do not free the resulting string."]
    pub fn exr_get_file_name(
        ctxt: exr_const_context_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the file version and flags the context is for as\n parsed during the start routine."]
    pub fn exr_get_file_version_and_flags(
        ctxt: exr_const_context_t,
        ver: *mut u32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the user data the context was constructed with. This\n is perhaps useful in the error handler callback to jump back into\n an object the user controls."]
    pub fn exr_get_user_data(
        ctxt: exr_const_context_t,
        userdata: *mut *mut ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Any opaque attribute data entry of the specified type is tagged\n with these functions enabling downstream users to unpack (or pack)\n the data.\n\n The library handles the memory packed data internally, but the\n handler is expected to allocate and manage memory for the\n *unpacked* buffer (the library will call the destroy function).\n\n NB: the pack function will be called twice (unless there is a\n memory failure), the first with a `NULL` buffer, requesting the\n maximum size (or exact size if known) for the packed buffer, then\n the second to fill the output packed buffer, at which point the\n size can be re-updated to have the final, precise size to put into\n the file."]
    pub fn exr_register_attr_type_handler(
        ctxt: exr_context_t,
        type_: *const ::std::os::raw::c_char,
        unpack_func_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                ctxt: exr_context_t,
                data: *const ::std::os::raw::c_void,
                attrsize: i32,
                outsize: *mut i32,
                outbuffer: *mut *mut ::std::os::raw::c_void,
            ) -> exr_result_t,
        >,
        pack_func_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                ctxt: exr_context_t,
                data: *const ::std::os::raw::c_void,
                datasize: i32,
                outsize: *mut i32,
                outbuffer: *mut ::std::os::raw::c_void,
            ) -> exr_result_t,
        >,
        destroy_unpacked_func_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                ctxt: exr_context_t,
                data: *mut ::std::os::raw::c_void,
                datasize: i32,
            ),
        >,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Enable long name support in the output context"]
    pub fn exr_set_longname_support(
        ctxt: exr_context_t,
        onoff: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Write the header data.\n\n Opening a new output file has a small initialization state problem\n compared to opening for read/update: we need to enable the user\n to specify an arbitrary set of metadata across an arbitrary number\n of parts. To avoid having to create the list of parts and entire\n metadata up front, prior to calling the above exr_start_write(),\n allow the data to be set, then once this is called, it switches\n into a mode where the library assumes the data is now valid.\n\n It will recompute the number of chunks that will be written, and\n reset the chunk offsets. If you modify file attributes or part\n information after a call to this, it will error."]
    pub fn exr_write_header(ctxt: exr_context_t) -> exr_result_t;
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_NONE: exr_compression_t = exr_compression_t(0);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_RLE: exr_compression_t = exr_compression_t(1);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_ZIPS: exr_compression_t = exr_compression_t(2);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_ZIP: exr_compression_t = exr_compression_t(3);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_PIZ: exr_compression_t = exr_compression_t(4);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_PXR24: exr_compression_t = exr_compression_t(5);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_B44: exr_compression_t = exr_compression_t(6);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_B44A: exr_compression_t = exr_compression_t(7);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_DWAA: exr_compression_t = exr_compression_t(8);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_DWAB: exr_compression_t = exr_compression_t(9);
}
impl exr_compression_t {
    #[doc = "< Invalid value, provided for range checking."]
    pub const EXR_COMPRESSION_LAST_TYPE: exr_compression_t =
        exr_compression_t(10);
}
#[repr(transparent)]
#[doc = " Enum declaring allowed values for \\c uint8_t value stored in built-in compression type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_compression_t(pub ::std::os::raw::c_int);
impl exr_envmap_t {
    pub const EXR_ENVMAP_LATLONG: exr_envmap_t = exr_envmap_t(0);
}
impl exr_envmap_t {
    pub const EXR_ENVMAP_CUBE: exr_envmap_t = exr_envmap_t(1);
}
impl exr_envmap_t {
    #[doc = "< Invalid value, provided for range checking."]
    pub const EXR_ENVMAP_LAST_TYPE: exr_envmap_t = exr_envmap_t(2);
}
#[repr(transparent)]
#[doc = " Enum declaring allowed values for \\c uint8_t value stored in built-in env map type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_envmap_t(pub ::std::os::raw::c_int);
impl exr_lineorder_t {
    pub const EXR_LINEORDER_INCREASING_Y: exr_lineorder_t = exr_lineorder_t(0);
}
impl exr_lineorder_t {
    pub const EXR_LINEORDER_DECREASING_Y: exr_lineorder_t = exr_lineorder_t(1);
}
impl exr_lineorder_t {
    pub const EXR_LINEORDER_RANDOM_Y: exr_lineorder_t = exr_lineorder_t(2);
}
impl exr_lineorder_t {
    #[doc = "< Invalid value, provided for range checking."]
    pub const EXR_LINEORDER_LAST_TYPE: exr_lineorder_t = exr_lineorder_t(3);
}
#[repr(transparent)]
#[doc = " Enum declaring allowed values for \\c uint8_t value stored in \\c lineOrder type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_lineorder_t(pub ::std::os::raw::c_int);
impl exr_storage_t {
    #[doc = "< Corresponds to type of \\c scanlineimage."]
    pub const EXR_STORAGE_SCANLINE: exr_storage_t = exr_storage_t(0);
}
impl exr_storage_t {
    #[doc = "< Corresponds to type of \\c tiledimage."]
    pub const EXR_STORAGE_TILED: exr_storage_t = exr_storage_t(1);
}
impl exr_storage_t {
    #[doc = "< Corresponds to type of \\c deepscanline."]
    pub const EXR_STORAGE_DEEP_SCANLINE: exr_storage_t = exr_storage_t(2);
}
impl exr_storage_t {
    #[doc = "< Corresponds to type of \\c deeptile."]
    pub const EXR_STORAGE_DEEP_TILED: exr_storage_t = exr_storage_t(3);
}
impl exr_storage_t {
    #[doc = "< Invalid value, provided for range checking."]
    pub const EXR_STORAGE_LAST_TYPE: exr_storage_t = exr_storage_t(4);
}
impl exr_storage_t {
    #[doc = "< An unknown type, provided for future proofing."]
    pub const EXR_STORAGE_UNKNOWN: exr_storage_t = exr_storage_t(5);
}
#[repr(transparent)]
#[doc = " Enum declaring allowed values for part type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_storage_t(pub ::std::os::raw::c_int);
impl exr_tile_level_mode_t {
    #[doc = "< Single level of image data."]
    pub const EXR_TILE_ONE_LEVEL: exr_tile_level_mode_t =
        exr_tile_level_mode_t(0);
}
impl exr_tile_level_mode_t {
    #[doc = "< Mipmapped image data."]
    pub const EXR_TILE_MIPMAP_LEVELS: exr_tile_level_mode_t =
        exr_tile_level_mode_t(1);
}
impl exr_tile_level_mode_t {
    #[doc = "< Ripmapped image data."]
    pub const EXR_TILE_RIPMAP_LEVELS: exr_tile_level_mode_t =
        exr_tile_level_mode_t(2);
}
impl exr_tile_level_mode_t {
    #[doc = "< Invalid value, provided for range checking."]
    pub const EXR_TILE_LAST_TYPE: exr_tile_level_mode_t =
        exr_tile_level_mode_t(3);
}
#[repr(transparent)]
#[doc = " @brief Enum representing what type of tile information is contained."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_tile_level_mode_t(pub ::std::os::raw::c_int);
impl exr_tile_round_mode_t {
    pub const EXR_TILE_ROUND_DOWN: exr_tile_round_mode_t =
        exr_tile_round_mode_t(0);
}
impl exr_tile_round_mode_t {
    pub const EXR_TILE_ROUND_UP: exr_tile_round_mode_t =
        exr_tile_round_mode_t(1);
}
impl exr_tile_round_mode_t {
    pub const EXR_TILE_ROUND_LAST_TYPE: exr_tile_round_mode_t =
        exr_tile_round_mode_t(2);
}
#[repr(transparent)]
#[doc = " @brief Enum representing how to scale positions between levels."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_tile_round_mode_t(pub ::std::os::raw::c_int);
impl exr_pixel_type_t {
    pub const EXR_PIXEL_UINT: exr_pixel_type_t = exr_pixel_type_t(0);
}
impl exr_pixel_type_t {
    pub const EXR_PIXEL_HALF: exr_pixel_type_t = exr_pixel_type_t(1);
}
impl exr_pixel_type_t {
    pub const EXR_PIXEL_FLOAT: exr_pixel_type_t = exr_pixel_type_t(2);
}
impl exr_pixel_type_t {
    pub const EXR_PIXEL_LAST_TYPE: exr_pixel_type_t = exr_pixel_type_t(3);
}
#[repr(transparent)]
#[doc = " @brief Enum capturing the underlying data type on a channel."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_pixel_type_t(pub ::std::os::raw::c_int);
impl exr_deep_image_state_t {
    pub const EXR_DIS_MESSY: exr_deep_image_state_t = exr_deep_image_state_t(0);
}
impl exr_deep_image_state_t {
    pub const EXR_DIS_SORTED: exr_deep_image_state_t =
        exr_deep_image_state_t(1);
}
impl exr_deep_image_state_t {
    pub const EXR_DIS_NON_OVERLAPPING: exr_deep_image_state_t =
        exr_deep_image_state_t(2);
}
impl exr_deep_image_state_t {
    pub const EXR_DIS_TIDY: exr_deep_image_state_t = exr_deep_image_state_t(3);
}
impl exr_deep_image_state_t {
    #[doc = "< Invalid value, provided for range checking."]
    pub const EXR_DIS_LAST_TYPE: exr_deep_image_state_t =
        exr_deep_image_state_t(4);
}
#[repr(transparent)]
#[doc = " Enum declaring allowed values for \\c uint8_t value stored in \\c deepImageState type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_deep_image_state_t(pub ::std::os::raw::c_int);
#[doc = " @brief Struct to hold color chromaticities to interpret the tristimulus color values in the image data."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_chromaticities_t {
    pub red_x: f32,
    pub red_y: f32,
    pub green_x: f32,
    pub green_y: f32,
    pub blue_x: f32,
    pub blue_y: f32,
    pub white_x: f32,
    pub white_y: f32,
}
#[test]
fn bindgen_test_layout_exr_attr_chromaticities_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_chromaticities_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_chromaticities_t>(),
        32usize,
        concat!("Size of: ", stringify!(exr_attr_chromaticities_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_chromaticities_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_chromaticities_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(red_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(red_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(green_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(green_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(blue_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_y) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(blue_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(white_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(white_y)
        )
    );
}
#[doc = " @brief Struct to hold keycode information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_keycode_t {
    pub film_mfc_code: i32,
    pub film_type: i32,
    pub prefix: i32,
    pub count: i32,
    pub perf_offset: i32,
    pub perfs_per_frame: i32,
    pub perfs_per_count: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_keycode_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_keycode_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_keycode_t>(),
        28usize,
        concat!("Size of: ", stringify!(exr_attr_keycode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_keycode_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_keycode_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).film_mfc_code) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(film_mfc_code)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).film_type) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(film_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).perf_offset) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(perf_offset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).perfs_per_frame) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(perfs_per_frame)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).perfs_per_count) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(perfs_per_count)
        )
    );
}
#[doc = " @brief struct to hold a 32-bit floating-point 3x3 matrix."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m33f_t {
    pub m: [f32; 9usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m33f_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_m33f_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m33f_t>(),
        36usize,
        concat!("Size of: ", stringify!(exr_attr_m33f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m33f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m33f_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_m33f_t),
            "::",
            stringify!(m)
        )
    );
}
#[doc = " @brief struct to hold a 64-bit floating-point 3x3 matrix."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m33d_t {
    pub m: [f64; 9usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m33d_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_m33d_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m33d_t>(),
        72usize,
        concat!("Size of: ", stringify!(exr_attr_m33d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m33d_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m33d_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_m33d_t),
            "::",
            stringify!(m)
        )
    );
}
#[doc = " @brief Struct to hold a 32-bit floating-point 4x4 matrix."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m44f_t {
    pub m: [f32; 16usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m44f_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_m44f_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m44f_t>(),
        64usize,
        concat!("Size of: ", stringify!(exr_attr_m44f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m44f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m44f_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_m44f_t),
            "::",
            stringify!(m)
        )
    );
}
#[doc = " @brief Struct to hold a 64-bit floating-point 4x4 matrix."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m44d_t {
    pub m: [f64; 16usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m44d_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_m44d_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m44d_t>(),
        128usize,
        concat!("Size of: ", stringify!(exr_attr_m44d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m44d_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m44d_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_m44d_t),
            "::",
            stringify!(m)
        )
    );
}
#[doc = " @brief Struct to hold an integer ratio value."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_rational_t {
    pub num: i32,
    pub denom: u32,
}
#[test]
fn bindgen_test_layout_exr_attr_rational_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_rational_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_rational_t>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_rational_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_rational_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_rational_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_rational_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_rational_t),
            "::",
            stringify!(denom)
        )
    );
}
#[doc = " @brief Struct to hold timecode information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_timecode_t {
    pub time_and_flags: u32,
    pub user_data: u32,
}
#[test]
fn bindgen_test_layout_exr_attr_timecode_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_timecode_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_timecode_t>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_timecode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_timecode_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_timecode_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).time_and_flags) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_timecode_t),
            "::",
            stringify!(time_and_flags)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_timecode_t),
            "::",
            stringify!(user_data)
        )
    );
}
#[doc = " @brief Struct to hold an integer box/region definition."]
#[repr(C)]
pub struct exr_attr_box2i_t {
    pub min: exr_attr_v2i_t,
    pub max: exr_attr_v2i_t,
}
#[test]
fn bindgen_test_layout_exr_attr_box2i_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_box2i_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_box2i_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_box2i_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_box2i_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_box2i_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_box2i_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_box2i_t),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " @brief Struct to hold a floating-point box/region definition."]
#[repr(C)]
pub struct exr_attr_box2f_t {
    pub min: exr_attr_v2f_t,
    pub max: exr_attr_v2f_t,
}
#[test]
fn bindgen_test_layout_exr_attr_box2f_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_box2f_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_box2f_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_box2f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_box2f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_box2f_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_box2f_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_box2f_t),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " @brief Struct holding base tiledesc attribute type defined in spec\n\n NB: This is in a tightly packed area so it can be read directly, be\n careful it doesn't become padded to the next \\c uint32_t boundary."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_tiledesc_t {
    pub x_size: u32,
    pub y_size: u32,
    pub level_and_round: u8,
}
#[test]
fn bindgen_test_layout_exr_attr_tiledesc_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_tiledesc_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_tiledesc_t>(),
        9usize,
        concat!("Size of: ", stringify!(exr_attr_tiledesc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_tiledesc_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_tiledesc_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_tiledesc_t),
            "::",
            stringify!(x_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_tiledesc_t),
            "::",
            stringify!(y_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).level_and_round) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_tiledesc_t),
            "::",
            stringify!(level_and_round)
        )
    );
}
#[doc = " Storage for a string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_string_t {
    pub length: i32,
    #[doc = " If this is non-zero, the string owns the data, if 0, is a const ref to a static string."]
    pub alloc_size: i32,
    pub str_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_exr_attr_string_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_string_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_string_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_t),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_t),
            "::",
            stringify!(str_)
        )
    );
}
#[doc = " Storage for a string vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_string_vector_t {
    pub n_strings: i32,
    #[doc = " If this is non-zero, the string vector owns the data, if 0, is a const ref."]
    pub alloc_size: i32,
    pub strings: *const exr_attr_string_t,
}
#[test]
fn bindgen_test_layout_exr_attr_string_vector_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_string_vector_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_string_vector_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_string_vector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_string_vector_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_string_vector_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).n_strings) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_vector_t),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_vector_t),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_vector_t),
            "::",
            stringify!(strings)
        )
    );
}
#[doc = " Float vector storage struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_float_vector_t {
    pub length: i32,
    #[doc = " If this is non-zero, the float vector owns the data, if 0, is a const ref."]
    pub alloc_size: i32,
    pub arr: *const f32,
}
#[test]
fn bindgen_test_layout_exr_attr_float_vector_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_float_vector_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_float_vector_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_float_vector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_float_vector_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_float_vector_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_float_vector_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_float_vector_t),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_float_vector_t),
            "::",
            stringify!(arr)
        )
    );
}
impl exr_perceptual_treatment_t {
    pub const EXR_PERCEPTUALLY_LOGARITHMIC: exr_perceptual_treatment_t =
        exr_perceptual_treatment_t(0);
}
impl exr_perceptual_treatment_t {
    pub const EXR_PERCEPTUALLY_LINEAR: exr_perceptual_treatment_t =
        exr_perceptual_treatment_t(1);
}
#[repr(transparent)]
#[doc = " Hint for lossy compression methods about how to treat values\n (logarithmic or linear), meaning a human sees values like R, G, B,\n luminance difference between 0.1 and 0.2 as about the same as 1.0\n to 2.0 (logarithmic), where chroma coordinates are closer to linear\n (0.1 and 0.2 is about the same difference as 1.0 and 1.1)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_perceptual_treatment_t(pub ::std::os::raw::c_int);
#[doc = " Individual channel information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_chlist_entry_t {
    pub name: exr_attr_string_t,
    #[doc = " Data representation for these pixels: uint, half, float."]
    pub pixel_type: exr_pixel_type_t,
    #[doc = " Possible values are 0 and 1 per docs exr_perceptual_treatment_t."]
    pub p_linear: u8,
    pub reserved: [u8; 3usize],
    pub x_sampling: i32,
    pub y_sampling: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_chlist_entry_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_chlist_entry_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_chlist_entry_t>(),
        32usize,
        concat!("Size of: ", stringify!(exr_attr_chlist_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_chlist_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_chlist_entry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pixel_type) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(pixel_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).p_linear) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(p_linear)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).x_sampling) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(x_sampling)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).y_sampling) as usize - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(y_sampling)
        )
    );
}
#[doc = " List of channel information (sorted alphabetically)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_chlist_t {
    pub num_channels: ::std::os::raw::c_int,
    pub num_alloced: ::std::os::raw::c_int,
    pub entries: *const exr_attr_chlist_entry_t,
}
#[test]
fn bindgen_test_layout_exr_attr_chlist_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_chlist_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_chlist_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_chlist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_chlist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_chlist_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_channels) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_t),
            "::",
            stringify!(num_channels)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_alloced) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_t),
            "::",
            stringify!(num_alloced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_t),
            "::",
            stringify!(entries)
        )
    );
}
#[doc = " @brief Struct to define attributes of an embedded preview image."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_preview_t {
    pub width: u32,
    pub height: u32,
    #[doc = " If this is non-zero, the preview owns the data, if 0, is a const ref."]
    pub alloc_size: usize,
    pub rgba: *const u8,
}
#[test]
fn bindgen_test_layout_exr_attr_preview_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_preview_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_preview_t>(),
        24usize,
        concat!("Size of: ", stringify!(exr_attr_preview_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_preview_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_preview_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_preview_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_preview_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_preview_t),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgba) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_preview_t),
            "::",
            stringify!(rgba)
        )
    );
}
#[doc = " Custom storage structure for opaque data.\n\n Handlers for opaque types can be registered, then when a\n non-builtin type is encountered with a registered handler, the\n function pointers to unpack/pack it will be set up.\n\n @sa exr_register_attr_type_handler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_opaquedata_t {
    pub size: i32,
    pub unpacked_size: i32,
    #[doc = " If this is non-zero, the struct owns the data, if 0, is a const ref."]
    pub packed_alloc_size: i32,
    pub pad: [u8; 4usize],
    pub packed_data: *mut ::std::os::raw::c_void,
    #[doc = " When an application wants to have custom data, they can store\n an unpacked form here which will be requested to be destroyed\n upon destruction of the attribute."]
    pub unpacked_data: *mut ::std::os::raw::c_void,
    #[doc = " An application can register an attribute handler which then\n fills in these function pointers. This allows a user to delay\n the expansion of the custom type until access is desired, and\n similarly, to delay the packing of the data until write time."]
    pub unpack_func_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            ctxt: exr_context_t,
            data: *const ::std::os::raw::c_void,
            attrsize: i32,
            outsize: *mut i32,
            outbuffer: *mut *mut ::std::os::raw::c_void,
        ) -> exr_result_t,
    >,
    pub pack_func_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            ctxt: exr_context_t,
            data: *const ::std::os::raw::c_void,
            datasize: i32,
            outsize: *mut i32,
            outbuffer: *mut ::std::os::raw::c_void,
        ) -> exr_result_t,
    >,
    pub destroy_unpacked_func_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            ctxt: exr_context_t,
            data: *mut ::std::os::raw::c_void,
            attrsize: i32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_exr_attr_opaquedata_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attr_opaquedata_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attr_opaquedata_t>(),
        56usize,
        concat!("Size of: ", stringify!(exr_attr_opaquedata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_opaquedata_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_opaquedata_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unpacked_size) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(unpacked_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_alloc_size) as usize
                - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(packed_alloc_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_data) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(packed_data)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unpacked_data) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(unpacked_data)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unpack_func_ptr) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(unpack_func_ptr)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pack_func_ptr) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(pack_func_ptr)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).destroy_unpacked_func_ptr) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(destroy_unpacked_func_ptr)
        )
    );
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_UNKNOWN: exr_attribute_type_t = exr_attribute_type_t(0);
}
impl exr_attribute_type_t {
    #[doc = "< Integer region definition. @see exr_attr_box2i_t."]
    pub const EXR_ATTR_BOX2I: exr_attribute_type_t = exr_attribute_type_t(1);
}
impl exr_attribute_type_t {
    #[doc = "< Float region definition. @see exr_attr_box2f_t."]
    pub const EXR_ATTR_BOX2F: exr_attribute_type_t = exr_attribute_type_t(2);
}
impl exr_attribute_type_t {
    #[doc = "< Definition of channels in file @see exr_chlist_entry."]
    pub const EXR_ATTR_CHLIST: exr_attribute_type_t = exr_attribute_type_t(3);
}
impl exr_attribute_type_t {
    #[doc = "< Values to specify color space of colors in file @see exr_attr_chromaticities_t."]
    pub const EXR_ATTR_CHROMATICITIES: exr_attribute_type_t =
        exr_attribute_type_t(4);
}
impl exr_attribute_type_t {
    #[doc = "< ``uint8_t`` declaring compression present."]
    pub const EXR_ATTR_COMPRESSION: exr_attribute_type_t =
        exr_attribute_type_t(5);
}
impl exr_attribute_type_t {
    #[doc = "< Double precision floating point number."]
    pub const EXR_ATTR_DOUBLE: exr_attribute_type_t = exr_attribute_type_t(6);
}
impl exr_attribute_type_t {
    #[doc = "< ``uint8_t`` declaring environment map type."]
    pub const EXR_ATTR_ENVMAP: exr_attribute_type_t = exr_attribute_type_t(7);
}
impl exr_attribute_type_t {
    #[doc = "< Normal (4 byte) precision floating point number."]
    pub const EXR_ATTR_FLOAT: exr_attribute_type_t = exr_attribute_type_t(8);
}
impl exr_attribute_type_t {
    #[doc = "< List of normal (4 byte) precision floating point numbers."]
    pub const EXR_ATTR_FLOAT_VECTOR: exr_attribute_type_t =
        exr_attribute_type_t(9);
}
impl exr_attribute_type_t {
    #[doc = "< 32-bit signed integer value."]
    pub const EXR_ATTR_INT: exr_attribute_type_t = exr_attribute_type_t(10);
}
impl exr_attribute_type_t {
    #[doc = "< Struct recording keycode @see exr_attr_keycode_t."]
    pub const EXR_ATTR_KEYCODE: exr_attribute_type_t = exr_attribute_type_t(11);
}
impl exr_attribute_type_t {
    #[doc = "< ``uint8_t`` declaring scanline ordering."]
    pub const EXR_ATTR_LINEORDER: exr_attribute_type_t =
        exr_attribute_type_t(12);
}
impl exr_attribute_type_t {
    #[doc = "< 9 32-bit floats representing a 3x3 matrix."]
    pub const EXR_ATTR_M33F: exr_attribute_type_t = exr_attribute_type_t(13);
}
impl exr_attribute_type_t {
    #[doc = "< 9 64-bit floats representing a 3x3 matrix."]
    pub const EXR_ATTR_M33D: exr_attribute_type_t = exr_attribute_type_t(14);
}
impl exr_attribute_type_t {
    #[doc = "< 16 32-bit floats representing a 4x4 matrix."]
    pub const EXR_ATTR_M44F: exr_attribute_type_t = exr_attribute_type_t(15);
}
impl exr_attribute_type_t {
    #[doc = "< 16 64-bit floats representing a 4x4 matrix."]
    pub const EXR_ATTR_M44D: exr_attribute_type_t = exr_attribute_type_t(16);
}
impl exr_attribute_type_t {
    #[doc = "< 2 ``unsigned ints`` followed by 4 x w x h ``uint8_t`` image."]
    pub const EXR_ATTR_PREVIEW: exr_attribute_type_t = exr_attribute_type_t(17);
}
impl exr_attribute_type_t {
    #[doc = "< \\c int followed by ``unsigned int``"]
    pub const EXR_ATTR_RATIONAL: exr_attribute_type_t =
        exr_attribute_type_t(18);
}
impl exr_attribute_type_t {
    #[doc = "< ``int`` (length) followed by char string data."]
    pub const EXR_ATTR_STRING: exr_attribute_type_t = exr_attribute_type_t(19);
}
impl exr_attribute_type_t {
    #[doc = "< 0 or more text strings (int + string). number is based on attribute size."]
    pub const EXR_ATTR_STRING_VECTOR: exr_attribute_type_t =
        exr_attribute_type_t(20);
}
impl exr_attribute_type_t {
    #[doc = "< 2 ``unsigned ints`` ``xSize``, ``ySize`` followed by mode."]
    pub const EXR_ATTR_TILEDESC: exr_attribute_type_t =
        exr_attribute_type_t(21);
}
impl exr_attribute_type_t {
    #[doc = "< 2 ``unsigned ints`` time and flags, user data."]
    pub const EXR_ATTR_TIMECODE: exr_attribute_type_t =
        exr_attribute_type_t(22);
}
impl exr_attribute_type_t {
    #[doc = "< Pair of 32-bit integers."]
    pub const EXR_ATTR_V2I: exr_attribute_type_t = exr_attribute_type_t(23);
}
impl exr_attribute_type_t {
    #[doc = "< Pair of 32-bit floats."]
    pub const EXR_ATTR_V2F: exr_attribute_type_t = exr_attribute_type_t(24);
}
impl exr_attribute_type_t {
    #[doc = "< Pair of 64-bit floats."]
    pub const EXR_ATTR_V2D: exr_attribute_type_t = exr_attribute_type_t(25);
}
impl exr_attribute_type_t {
    #[doc = "< Set of 3 32-bit integers."]
    pub const EXR_ATTR_V3I: exr_attribute_type_t = exr_attribute_type_t(26);
}
impl exr_attribute_type_t {
    #[doc = "< Set of 3 32-bit floats."]
    pub const EXR_ATTR_V3F: exr_attribute_type_t = exr_attribute_type_t(27);
}
impl exr_attribute_type_t {
    #[doc = "< Set of 3 64-bit floats."]
    pub const EXR_ATTR_V3D: exr_attribute_type_t = exr_attribute_type_t(28);
}
impl exr_attribute_type_t {
    #[doc = "< ``uint8_t`` declaring deep image state."]
    pub const EXR_ATTR_DEEP_IMAGE_STATE: exr_attribute_type_t =
        exr_attribute_type_t(29);
}
impl exr_attribute_type_t {
    #[doc = "< User/unknown provided type."]
    pub const EXR_ATTR_OPAQUE: exr_attribute_type_t = exr_attribute_type_t(30);
}
impl exr_attribute_type_t {
    pub const EXR_ATTR_LAST_KNOWN_TYPE: exr_attribute_type_t =
        exr_attribute_type_t(31);
}
#[repr(transparent)]
#[doc = " @brief Built-in/native attribute type enum.\n\n This will enable us to do a tagged type struct to generically store\n attributes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_attribute_type_t(pub ::std::os::raw::c_int);
#[doc = " @brief Storage, name and type information for an attribute.\n\n Attributes (metadata) for the file cause a surprising amount of\n overhead. It is not uncommon for a production-grade EXR to have\n many attributes. As such, the attribute struct is designed in a\n slightly more complicated manner. It is optimized to have the\n storage for that attribute: the struct itself, the name, the type,\n and the data all allocated as one block. Further, the type and\n standard names may use a static string to avoid allocating space\n for those as necessary with the pointers pointing to static strings\n (not to be freed). Finally, small values are optimized for."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_attribute_t {
    #[doc = " Name of the attribute."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " String type name of the attribute."]
    pub type_name: *const ::std::os::raw::c_char,
    #[doc = " Length of name string (short flag is 31 max, long allows 255)."]
    pub name_length: u8,
    #[doc = " Length of type string (short flag is 31 max, long allows 255)."]
    pub type_name_length: u8,
    pub pad: [u8; 2usize],
    #[doc = " Enum of the attribute type."]
    pub type_: exr_attribute_type_t,
    pub __bindgen_anon_1: exr_attribute_t__bindgen_ty_1,
}
#[doc = " Union of pointers of different types that can be used to type\n pun to an appropriate type for builtins. Do note that while\n this looks like a big thing, it is only the size of a single\n pointer.  These are all pointers into some other data block\n storing the value you want, with the exception of the pod types\n which are just put in place (i.e. small value optimization).\n\n The attribute type \\c type should directly correlate to one\n of these entries."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union exr_attribute_t__bindgen_ty_1 {
    pub uc: u8,
    pub d: f64,
    pub f: f32,
    pub i: i32,
    pub box2i: *mut exr_attr_box2i_t,
    pub box2f: *mut exr_attr_box2f_t,
    pub chlist: *mut exr_attr_chlist_t,
    pub chromaticities: *mut exr_attr_chromaticities_t,
    pub keycode: *mut exr_attr_keycode_t,
    pub floatvector: *mut exr_attr_float_vector_t,
    pub m33f: *mut exr_attr_m33f_t,
    pub m33d: *mut exr_attr_m33d_t,
    pub m44f: *mut exr_attr_m44f_t,
    pub m44d: *mut exr_attr_m44d_t,
    pub preview: *mut exr_attr_preview_t,
    pub rational: *mut exr_attr_rational_t,
    pub string: *mut exr_attr_string_t,
    pub stringvector: *mut exr_attr_string_vector_t,
    pub tiledesc: *mut exr_attr_tiledesc_t,
    pub timecode: *mut exr_attr_timecode_t,
    pub v2i: *mut exr_attr_v2i_t,
    pub v2f: *mut exr_attr_v2f_t,
    pub v2d: *mut exr_attr_v2d_t,
    pub v3i: *mut exr_attr_v3i_t,
    pub v3f: *mut exr_attr_v3f_t,
    pub v3d: *mut exr_attr_v3d_t,
    pub opaque: *mut exr_attr_opaquedata_t,
    pub rawptr: *mut u8,
}
#[test]
fn bindgen_test_layout_exr_attribute_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attribute_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attribute_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attribute_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attribute_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attribute_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(uc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).box2i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(box2i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).box2f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(box2f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(chlist)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).chromaticities) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(chromaticities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keycode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).floatvector) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(floatvector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m33f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(m33f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m33d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(m33d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m44f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(m44f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m44d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(m44d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preview) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(preview)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).rational) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(rational)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).stringvector) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(stringvector)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tiledesc) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(tiledesc)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).timecode) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(timecode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v2i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v2i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v2f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v2f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v2d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v2d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v3i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v3i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v3f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v3f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v3d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v3d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rawptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(rawptr)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_attribute_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_attribute_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_attribute_t>(),
        32usize,
        concat!("Size of: ", stringify!(exr_attribute_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attribute_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attribute_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).name_length) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(name_length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).type_name_length) as usize
                - ptr as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(type_name_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " @brief Query how many parts are in the file."]
    pub fn exr_get_count(
        ctxt: exr_const_context_t,
        count: *mut ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the part name for the specified part.\n\n NB: If this file is a single part file and name has not been set, this\n will return `NULL`."]
    pub fn exr_get_name(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the storage type for the specified part."]
    pub fn exr_get_storage(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_storage_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Define a new part in the file."]
    pub fn exr_add_part(
        ctxt: exr_context_t,
        partname: *const ::std::os::raw::c_char,
        type_: exr_storage_t,
        new_index: *mut ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query how many levels are in the specified part.\n\n If the part is a tiled part, fill in how many tile levels are present.\n\n Return `ERR_SUCCESS` on success, an error otherwise (i.e. if the part\n is not tiled).\n\n It is valid to pass `NULL` to either of the @p levelsx or @p levelsy\n arguments, which enables testing if this part is a tiled part, or\n if you don't need both (i.e. in the case of a mip-level tiled\n image)"]
    pub fn exr_get_tile_levels(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelsx: *mut i32,
        levelsy: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the tile size for a particular level in the specified part.\n\n If the part is a tiled part, fill in the tile size for the\n specified part/level.\n\n Return `ERR_SUCCESS` on success, an error otherwise (i.e. if the\n part is not tiled).\n\n It is valid to pass `NULL` to either of the @p tilew or @p tileh\n arguments, which enables testing if this part is a tiled part, or\n if you don't need both (i.e. in the case of a mip-level tiled\n image)"]
    pub fn exr_get_tile_sizes(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        tilew: *mut i32,
        tileh: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the tile count for a particular level in the specified part.\n\n If the part is a tiled part, fills in the count for the\n specified levels.\n\n Return `ERR_SUCCESS` on success, an error otherwise (i.e. if the part\n is not tiled).\n\n It is valid to pass `NULL` to either of the @p countx or @p county\n arguments, which enables testing if this part is a tiled part, or\n if you don't need both for some reason."]
    pub fn exr_get_tile_counts(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        countx: *mut i32,
        county: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the data sizes for a particular level in the specified part.\n\n If the part is a tiled part, fill in the width/height for the\n specified levels.\n\n Return `ERR_SUCCESS` on success, an error otherwise (i.e. if the part\n is not tiled).\n\n It is valid to pass `NULL` to either of the @p levw or @p levh\n arguments, which enables testing if this part is a tiled part, or\n if you don't need both for some reason."]
    pub fn exr_get_level_sizes(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        levw: *mut i32,
        levh: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Return the number of chunks contained in this part of the file.\n\n As in the technical documentation for OpenEXR, the chunk is the\n generic term for a pixel data block. This is the atomic unit that\n this library uses to negotiate data to and from a context.\n\n This should be used as a basis for splitting up how a file is\n processed. Depending on the compression, a different number of\n scanlines are encoded in each chunk, and since those need to be\n encoded/decoded as a block, the chunk should be the basis for I/O\n as well."]
    pub fn exr_get_chunk_count(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Return a pointer to the chunk table and the count\n\n TODO: consider removing this prior to release once C++ fully converted"]
    pub fn exr_get_chunk_table(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        table: *mut *mut u64,
        count: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Return whether the chunk table for this part is completely written.\n\n This only validates that all the offsets are valid.\n\n return EXR_ERR_INCOMPLETE_CHUNK_TABLE when incomplete, EXR_ERR_SUCCESS\n if it appears ok, or another error if otherwise problematic"]
    pub fn exr_validate_chunk_table(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Return the number of scanlines chunks for this file part.\n\n When iterating over a scanline file, this may be an easier metric\n for multi-threading or other access than only negotiating chunk\n counts, and so is provided as a utility."]
    pub fn exr_get_scanlines_per_chunk(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Return the maximum unpacked size of a chunk for the file part.\n\n This may be used ahead of any actual reading of data, so can be\n used to pre-allocate buffers for multiple threads in one block or\n whatever your application may require."]
    pub fn exr_get_chunk_unpacked_size(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut u64,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the zip compression level used for the specified part.\n\n This only applies when the compression method involves using zip\n compression (zip, zips, some modes of DWAA/DWAB).\n\n This value is NOT persisted in the file, and only exists for the\n lifetime of the context, so will be at the default value when just\n reading a file."]
    pub fn exr_get_zip_compression_level(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        level: *mut ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the zip compression method used for the specified part.\n\n This only applies when the compression method involves using zip\n compression (zip, zips, some modes of DWAA/DWAB).\n\n This value is NOT persisted in the file, and only exists for the\n lifetime of the context, so this value will be ignored when\n reading a file."]
    pub fn exr_set_zip_compression_level(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the dwa compression level used for the specified part.\n\n This only applies when the compression method is DWAA/DWAB.\n\n This value is NOT persisted in the file, and only exists for the\n lifetime of the context, so will be at the default value when just\n reading a file."]
    pub fn exr_get_dwa_compression_level(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        level: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the dwa compression method used for the specified part.\n\n This only applies when the compression method is DWAA/DWAB.\n\n This value is NOT persisted in the file, and only exists for the\n lifetime of the context, so this value will be ignored when\n reading a file."]
    pub fn exr_set_dwa_compression_level(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        level: f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the count of attributes in a part."]
    pub fn exr_get_attribute_count(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        count: *mut i32,
    ) -> exr_result_t;
}
impl exr_attr_list_access_mode {
    #[doc = "< Order they appear in the file"]
    pub const EXR_ATTR_LIST_FILE_ORDER: exr_attr_list_access_mode =
        exr_attr_list_access_mode(0);
}
impl exr_attr_list_access_mode {
    #[doc = "< Alphabetically sorted"]
    pub const EXR_ATTR_LIST_SORTED_ORDER: exr_attr_list_access_mode =
        exr_attr_list_access_mode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_attr_list_access_mode(pub ::std::os::raw::c_int);
pub use self::exr_attr_list_access_mode as exr_attr_list_access_mode_t;
extern "C" {
    #[doc = " @brief Query a particular attribute by index."]
    pub fn exr_get_attribute_by_index(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        mode: exr_attr_list_access_mode_t,
        idx: i32,
        outattr: *mut *const exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query a particular attribute by name."]
    pub fn exr_get_attribute_by_name(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        outattr: *mut *const exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the list of attributes in a part.\n\n This retrieves a list of attributes currently defined in a part.\n\n If outlist is `NULL`, this function still succeeds, filling only the\n count. In this manner, the user can allocate memory for the list of\n attributes, then re-call this function to get the full list."]
    pub fn exr_get_attribute_list(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        mode: exr_attr_list_access_mode_t,
        count: *mut i32,
        outlist: *mut *const exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Declare an attribute within the specified part.\n\n Only valid when a file is opened for write."]
    pub fn exr_attr_declare_by_type(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        newattr: *mut *mut exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Declare an attribute within the specified part.\n\n Only valid when a file is opened for write."]
    pub fn exr_attr_declare(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: exr_attribute_type_t,
        newattr: *mut *mut exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Initialize all required attributes for all files.\n\n NB: other file types do require other attributes, such as the tile\n description for a tiled file."]
    pub fn exr_initialize_required_attr(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        displayWindow: *const exr_attr_box2i_t,
        dataWindow: *const exr_attr_box2i_t,
        pixelaspectratio: f32,
        screenWindowCenter: *const exr_attr_v2f_t,
        screenWindowWidth: f32,
        lineorder: exr_lineorder_t,
        ctype: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Initialize all required attributes to default values:\n\n - `displayWindow` is set to (0, 0 -> @p width - 1, @p height - 1)\n - `dataWindow` is set to (0, 0 -> @p width - 1, @p height - 1)\n - `pixelAspectRatio` is set to 1.0\n - `screenWindowCenter` is set to 0.f, 0.f\n - `screenWindowWidth` is set to 1.f\n - `lineorder` is set to `INCREASING_Y`\n - `compression` is set to @p ctype"]
    pub fn exr_initialize_required_attr_simple(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        width: i32,
        height: i32,
        ctype: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Copy the attributes from one part to another.\n\n This allows one to quickly unassigned attributes from one source to another.\n\n If an attribute in the source part has not been yet set in the\n destination part, the item will be copied over.\n\n For example, when you add a part, the storage type and name\n attributes are required arguments to the definition of a new part,\n but channels has not yet been assigned. So by calling this with an\n input file as the source, you can copy the channel definitions (and\n any other unassigned attributes from the source)."]
    pub fn exr_copy_unset_attributes(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        source: exr_const_context_t,
        src_part_index: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the list of channels."]
    pub fn exr_get_channels(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        chlist: *mut *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Define a new channel to the output file part.\n\n The @p percept parameter is used for lossy compression techniques\n to indicate that the value represented is closer to linear (1) or\n closer to logarithmic (0). For r, g, b, luminance, this is normally\n 0."]
    pub fn exr_add_channel(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        ptype: exr_pixel_type_t,
        percept: exr_perceptual_treatment_t,
        xsamp: i32,
        ysamp: i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Copy the channels from another source.\n\n Useful if you are manually constructing the list or simply copying\n from an input file."]
    pub fn exr_set_channels(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        channels: *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the compression method used for the specified part."]
    pub fn exr_get_compression(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        compression: *mut exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the compression method used for the specified part."]
    pub fn exr_set_compression(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        ctype: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the data window for the specified part."]
    pub fn exr_get_data_window(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the data window for the specified part."]
    pub fn exr_set_data_window(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        dw: *const exr_attr_box2i_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the display window for the specified part."]
    pub fn exr_get_display_window(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the display window for the specified part."]
    pub fn exr_set_display_window(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        dw: *const exr_attr_box2i_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the line order for storing data in the specified part (use 0 for single part images)."]
    pub fn exr_get_lineorder(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the line order for storing data in the specified part (use 0 for single part images)."]
    pub fn exr_set_lineorder(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        lo: exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the pixel aspect ratio for the specified part (use 0 for single part images)."]
    pub fn exr_get_pixel_aspect_ratio(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        par: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the pixel aspect ratio for the specified part (use 0 for single part images)."]
    pub fn exr_set_pixel_aspect_ratio(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        par: f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the screen oriented window center for the specified part (use 0 for single part images)."]
    pub fn exr_get_screen_window_center(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        wc: *mut exr_attr_v2f_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the screen oriented window center for the specified part (use 0 for single part images)."]
    pub fn exr_set_screen_window_center(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        wc: *const exr_attr_v2f_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the screen oriented window width for the specified part (use 0 for single part images)."]
    pub fn exr_get_screen_window_width(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the screen oriented window width for the specified part (use 0 for single part images)."]
    pub fn exr_set_screen_window_width(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        ssw: f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the tiling info for a tiled part (use 0 for single part images)."]
    pub fn exr_get_tile_descriptor(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        xsize: *mut u32,
        ysize: *mut u32,
        level: *mut exr_tile_level_mode_t,
        round: *mut exr_tile_round_mode_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the tiling info for a tiled part (use 0 for single part images)."]
    pub fn exr_set_tile_descriptor(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        x_size: u32,
        y_size: u32,
        level_mode: exr_tile_level_mode_t,
        round_mode: exr_tile_round_mode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_name(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        val: *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_version(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_version(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        val: i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_chunk_count(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        val: i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @defgroup BuiltinAttributeHelpers Attribute utilities for builtin types\n\n @brief These are a group of functions for attributes that use the builtin types.\n\n @{"]
    pub fn exr_attr_get_box2i(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        outval: *mut exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_box2i(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: *const exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_box2f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        outval: *mut exr_attr_box2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_box2f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: *const exr_attr_box2f_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Zero-copy query of channel data.\n\n Do not free or manipulate the @p chlist data, or use\n after the lifetime of the context."]
    pub fn exr_attr_get_channels(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        chlist: *mut *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief This allows one to quickly copy the channels from one file\n to another."]
    pub fn exr_attr_set_channels(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        channels: *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_chromaticities(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        chroma: *mut exr_attr_chromaticities_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_chromaticities(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        chroma: *const exr_attr_chromaticities_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_compression(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_compression(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        comp: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_double(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut f64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_double(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: f64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_envmap(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_envmap_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_envmap(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        emap: exr_envmap_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_float(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_float(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Zero-copy query of float data.\n\n Do not free or manipulate the @p out data, or use after the\n lifetime of the context."]
    pub fn exr_attr_get_float_vector(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        sz: *mut i32,
        out: *mut *const f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_float_vector(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        sz: i32,
        vals: *const f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_int(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_int(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_keycode(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_keycode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_keycode(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        kc: *const exr_attr_keycode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_lineorder(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_lineorder(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        lo: exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m33f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m33f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m33f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m33f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m33d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m33d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m33d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m33d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m44f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m44f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m44f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m44f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m44d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m44d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m44d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m44d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_preview(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_preview_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_preview(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        p: *const exr_attr_preview_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_rational(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_rational_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_rational(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        r: *const exr_attr_rational_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Zero-copy query of string value.\n\n Do not modify the string pointed to by @p out, and do not use\n after the lifetime of the context."]
    pub fn exr_attr_get_string(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        length: *mut i32,
        out: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_string(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Zero-copy query of string data.\n\n Do not free the strings pointed to by the array.\n\n Must provide @p size.\n\n \\p out must be a ``const char**`` array large enough to hold\n the string pointers for the string vector when provided."]
    pub fn exr_attr_get_string_vector(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        size: *mut i32,
        out: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_string_vector(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        size: i32,
        sv: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_tiledesc(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_tiledesc_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_tiledesc(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        td: *const exr_attr_tiledesc_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_timecode(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_timecode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_timecode(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        tc: *const exr_attr_timecode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v2i(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v2i(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v2f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v2f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v2d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v2d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v2d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v2d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v3i(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v3i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v3i(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v3i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v3f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v3f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v3f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v3f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v3d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v3d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v3d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v3d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_user(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: *mut *const ::std::os::raw::c_char,
        size: *mut i32,
        out: *mut *const ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_user(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        size: i32,
        out: *const ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the chunk table offset for the part in question."]
    pub fn exr_get_chunk_table_offset(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        chunk_offset_out: *mut u64,
    ) -> exr_result_t;
}
#[doc = " Struct describing raw data information about a chunk.\n\n A chunk is the generic term for a pixel data block in an EXR file,\n as described in the OpenEXR File Layout documentation. This is\n common between all different forms of data that can be stored."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_chunk_info_t {
    pub idx: i32,
    #[doc = " For tiles, this is the tilex; for scans it is the x."]
    pub start_x: i32,
    #[doc = " For tiles, this is the tiley; for scans it is the scanline y."]
    pub start_y: i32,
    #[doc = "< For this chunk."]
    pub height: i32,
    #[doc = "< For this chunk."]
    pub width: i32,
    #[doc = "< For tiled files."]
    pub level_x: u8,
    #[doc = "< For tiled files."]
    pub level_y: u8,
    pub type_: u8,
    pub compression: u8,
    pub data_offset: u64,
    pub packed_size: u64,
    pub unpacked_size: u64,
    pub sample_count_data_offset: u64,
    pub sample_count_table_size: u64,
}
#[test]
fn bindgen_test_layout_exr_chunk_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_chunk_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_chunk_info_t>(),
        64usize,
        concat!("Size of: ", stringify!(exr_chunk_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_chunk_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_chunk_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(start_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(start_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(level_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level_y) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(level_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).compression) as usize - ptr as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(compression)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).data_offset) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_size) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(packed_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unpacked_size) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(unpacked_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sample_count_data_offset) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(sample_count_data_offset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sample_count_table_size) as usize
                - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(sample_count_table_size)
        )
    );
}
extern "C" {
    #[doc = " initialize chunk info with the default values from the specified part\n\n The 'x' and 'y' parameters are used to indicate the starting position\n of the chunk being initialized. This does not perform any I/O to validate\n and so the values are only indicative. (but can be used to do things\n like compress / decompress a chunk without having a file to actually\n read"]
    pub fn exr_chunk_default_initialize(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        box_: *const exr_attr_box2i_t,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_read_scanline_chunk_info(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_read_tile_chunk_info(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Read the packed data block for a chunk.\n\n This assumes that the buffer pointed to by @p packed_data is\n large enough to hold the chunk block info packed_size bytes."]
    pub fn exr_read_chunk(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        packed_data: *mut ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Read chunk for deep data.\n\n This allows one to read the packed data, the sample count data, or both.\n \\c exr_read_chunk also works to read deep data packed data,\n but this is a routine to get the sample count table and the packed\n data in one go, or if you want to pre-read the sample count data,\n you can get just that buffer."]
    pub fn exr_read_deep_chunk(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        packed_data: *mut ::std::os::raw::c_void,
        sample_data: *mut ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Initialize a \\c exr_chunk_info_t structure when encoding scanline\n data (similar to read but does not do anything with a chunk\n table)."]
    pub fn exr_write_scanline_chunk_info(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Initialize a \\c exr_chunk_info_t structure when encoding tiled data\n (similar to read but does not do anything with a chunk table)."]
    pub fn exr_write_tile_chunk_info(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @p y must the appropriate starting y for the specified chunk."]
    pub fn exr_write_scanline_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @p y must the appropriate starting y for the specified chunk."]
    pub fn exr_write_deep_scanline_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
        unpacked_size: u64,
        sample_data: *const ::std::os::raw::c_void,
        sample_data_size: u64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_tile_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_deep_tile_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
        unpacked_size: u64,
        sample_data: *const ::std::os::raw::c_void,
        sample_data_size: u64,
    ) -> exr_result_t;
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_PACKED: exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(0);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_UNPACKED:
        exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(1);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_COMPRESSED:
        exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(2);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_SCRATCH1:
        exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(3);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_SCRATCH2:
        exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(4);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_PACKED_SAMPLES:
        exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(5);
}
impl exr_transcoding_pipeline_buffer_id {
    pub const EXR_TRANSCODE_BUFFER_SAMPLES: exr_transcoding_pipeline_buffer_id =
        exr_transcoding_pipeline_buffer_id(6);
}
#[repr(transparent)]
#[doc = " Enum for use in a custom allocator in the encode/decode pipelines\n (that is, so the implementor knows whether to allocate on which\n device based on the buffer disposition)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_transcoding_pipeline_buffer_id(pub ::std::os::raw::c_int);
#[doc = " Enum for use in a custom allocator in the encode/decode pipelines\n (that is, so the implementor knows whether to allocate on which\n device based on the buffer disposition)."]
pub use self::exr_transcoding_pipeline_buffer_id as exr_transcoding_pipeline_buffer_id_t;
#[doc = " @brief Struct for negotiating buffers when decoding/encoding\n chunks of data.\n\n This is generic and meant to negotiate exr data bi-directionally,\n in that the same structure is used for both decoding and encoding\n chunks for read and write, respectively.\n\n The first half of the structure will be filled by the library, and\n the caller is expected to fill the second half appropriately."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exr_coding_channel_info_t {
    #[doc = " Channel name.\n\n This is provided as a convenient reference. Do not free, this\n refers to the internal data structure in the context."]
    pub channel_name: *const ::std::os::raw::c_char,
    #[doc = " Number of lines for this channel in this chunk.\n\n May be 0 or less than overall image height based on sampling\n (i.e. when in 4:2:0 type sampling)"]
    pub height: i32,
    #[doc = " Width in pixel count.\n\n May be 0 or less than overall image width based on sampling\n (i.e. 4:2:2 will have some channels have fewer values)."]
    pub width: i32,
    #[doc = " Horizontal subsampling information."]
    pub x_samples: i32,
    #[doc = " Vertical subsampling information."]
    pub y_samples: i32,
    #[doc = " Linear flag from channel definition (used by b44)."]
    pub p_linear: u8,
    #[doc = " How many bytes per pixel this channel consumes (2 for float16,\n 4 for float32/uint32)."]
    pub bytes_per_element: i8,
    #[doc = " Small form of exr_pixel_type_t enum (EXR_PIXEL_UINT/HALF/FLOAT)."]
    pub data_type: u16,
    #[doc = " How many bytes per pixel the input is or output should be\n (2 for float16, 4 for float32/uint32). Defaults to same\n size as input."]
    pub user_bytes_per_element: i16,
    #[doc = " Small form of exr_pixel_type_t enum\n (EXR_PIXEL_UINT/HALF/FLOAT). Defaults to same type as input."]
    pub user_data_type: u16,
    #[doc = " Increment to get to next pixel.\n\n This is in bytes. Must be specified when the decode pointer is\n specified (and always for encode).\n\n This is useful for implementing transcoding generically of\n planar or interleaved data. For planar data, where the layout\n is RRRRRGGGGGBBBBB, you can pass in 1 * bytes per component."]
    pub user_pixel_stride: i32,
    #[doc = " When \\c lines > 1 for a chunk, this is the increment used to get\n from beginning of line to beginning of next line.\n\n This is in bytes. Must be specified when the decode pointer is\n specified (and always for encode)."]
    pub user_line_stride: i32,
    pub __bindgen_anon_1: exr_coding_channel_info_t__bindgen_ty_1,
}
#[doc = " This data member has different requirements reading vs\n writing. When reading, if this is left as `NULL`, the channel\n will be skipped during read and not filled in.  During a write\n operation, this pointer is considered const and not\n modified. To make this more clear, a union is used here."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union exr_coding_channel_info_t__bindgen_ty_1 {
    pub decode_to_ptr: *mut u8,
    pub encode_from_ptr: *const u8,
}
#[test]
fn bindgen_test_layout_exr_coding_channel_info_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        exr_coding_channel_info_t__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_coding_channel_info_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_coding_channel_info_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).decode_to_ptr) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1),
            "::",
            stringify!(decode_to_ptr)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).encode_from_ptr) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1),
            "::",
            stringify!(encode_from_ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_coding_channel_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<exr_coding_channel_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exr_coding_channel_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(exr_coding_channel_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_coding_channel_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_coding_channel_info_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).channel_name) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(channel_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).x_samples) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(x_samples)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).y_samples) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(y_samples)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).p_linear) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(p_linear)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).bytes_per_element) as usize
                - ptr as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(bytes_per_element)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).user_bytes_per_element) as usize
                - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(user_bytes_per_element)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).user_data_type) as usize - ptr as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(user_data_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).user_pixel_stride) as usize
                - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(user_pixel_stride)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).user_line_stride) as usize
                - ptr as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(user_line_stride)
        )
    );
}
#[doc = " Struct meant to be used on a per-thread basis for writing exr data.\n\n As should be obvious, this structure is NOT thread safe, but rather\n meant to be used by separate threads, which can all be accessing\n the same context concurrently."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _exr_encode_pipeline {
    #[doc = " Used for versioning the decode pipeline in the future\n\n \\ref EXR_ENCODE_PIPELINE_INITIALIZER"]
    pub pipe_size: usize,
    #[doc = " The output channel information for this chunk.\n\n User is expected to fill the channel pointers for the input\n channels. For writing, all channels must be initialized prior\n to using exr_encoding_choose_default_routines(). If a custom pack routine\n is written, that is up to the implementor.\n\n Describes the channel information. This information is\n allocated dynamically during exr_encoding_initialize()."]
    pub channels: *mut exr_coding_channel_info_t,
    pub channel_count: i16,
    #[doc = " Encode flags to control the behavior."]
    pub encode_flags: u16,
    #[doc = " Copy of the parameters given to the initialize/update for convenience."]
    pub part_index: ::std::os::raw::c_int,
    pub context: exr_const_context_t,
    pub chunk: exr_chunk_info_t,
    #[doc = " Can be used by the user to pass custom context data through\n the encode pipeline."]
    pub encoding_user_data: *mut ::std::os::raw::c_void,
    #[doc = " The packed buffer where individual channels have been put into here.\n\n If `NULL`, will be allocated during the run of the pipeline.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub packed_buffer: *mut ::std::os::raw::c_void,
    #[doc = " Differing from the allocation size, the number of actual bytes"]
    pub packed_bytes: u64,
    #[doc = " Used when re-using the same encode pipeline struct to know if\n chunk is changed size whether current buffer is large enough\n\n If `NULL`, will be allocated during the run of the pipeline.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub packed_alloc_size: usize,
    #[doc = " For deep data. NB: the members NOT const because we need to\n temporarily swap it to xdr order and restore it (to avoid a\n duplicate buffer allocation).\n\n Depending on the flag set above, will be treated either as a\n cumulative list (n, n+m, n+m+o, ...), or an individual table\n (n, m, o, ...)."]
    pub sample_count_table: *mut i32,
    #[doc = " Allocated table size (to avoid re-allocations). Number of\n samples must always be width * height for the chunk."]
    pub sample_count_alloc_size: usize,
    #[doc = " Packed sample table (compressed, raw on disk representation)\n for deep or other non-image data."]
    pub packed_sample_count_table: *mut ::std::os::raw::c_void,
    #[doc = " Number of bytes to write (actual size) for the\n packed_sample_count_table."]
    pub packed_sample_count_bytes: usize,
    #[doc = " Allocated size (to avoid re-allocations) for the\n packed_sample_count_table."]
    pub packed_sample_count_alloc_size: usize,
    #[doc = " The compressed buffer, only needed for compressed files.\n\n If `NULL`, will be allocated during the run of the pipeline when\n needed.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub compressed_buffer: *mut ::std::os::raw::c_void,
    #[doc = " Must be filled in as the pipeline runs to inform the writing\n software about the compressed size of the chunk (if it is an\n uncompressed file or the compression would make the file\n larger, it is expected to be the packed_buffer)\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to zero here. Be cognizant of any\n custom allocators."]
    pub compressed_bytes: usize,
    #[doc = " Used when re-using the same encode pipeline struct to know if\n chunk is changed size whether current buffer is large enough.\n\n If `NULL`, will be allocated during the run of the pipeline when\n needed.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to zero here. Be cognizant of any\n custom allocators."]
    pub compressed_alloc_size: usize,
    #[doc = " A scratch buffer for intermediate results.\n\n If `NULL`, will be allocated during the run of the pipeline when\n needed.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub scratch_buffer_1: *mut ::std::os::raw::c_void,
    #[doc = " Used when re-using the same encode pipeline struct to know if\n chunk is changed size whether current buffer is large enough.\n\n If `NULL`, will be allocated during the run of the pipeline when\n needed.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub scratch_alloc_size_1: usize,
    #[doc = " Some compression routines may need a second scratch buffer.\n\n If `NULL`, will be allocated during the run of the pipeline when\n needed.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub scratch_buffer_2: *mut ::std::os::raw::c_void,
    #[doc = " Used when re-using the same encode pipeline struct to know if\n chunk is changed size whether current buffer is large enough."]
    pub scratch_alloc_size_2: usize,
    #[doc = " Enable a custom allocator for the different buffers (if\n encoding on a GPU). If `NULL`, will use the allocator from the\n context."]
    pub alloc_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: exr_transcoding_pipeline_buffer_id_t,
            arg2: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Enable a custom allocator for the different buffers (if\n encoding on a GPU). If `NULL`, will use the allocator from the\n context."]
    pub free_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: exr_transcoding_pipeline_buffer_id_t,
            arg2: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Function chosen based on the output layout of the channels of the part to\n decompress data.\n\n If the user has a custom method for the\n compression on this part, this can be changed after\n initialization."]
    pub convert_and_pack_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_encode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function chosen based on the compression type of the part to\n compress data.\n\n If the user has a custom compression method for the compression\n type on this part, this can be changed after initialization."]
    pub compress_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_encode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " This routine is used when waiting for other threads to finish\n writing previous chunks such that this thread can write this\n chunk. This is used for parts which have a specified chunk\n ordering (increasing/decreasing y) and the chunks can not be\n written randomly (as could be true for uncompressed).\n\n This enables the calling application to contribute thread time\n to other computation as needed, or just use something like\n pthread_yield().\n\n By default, this routine will be assigned to a function which\n returns an error, failing the encode immediately. In this way,\n it assumes that there is only one thread being used for\n writing.\n\n It is up to the user to provide an appropriate routine if\n performing multi-threaded writing."]
    pub yield_until_ready_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_encode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function chosen to write chunk data to the context.\n\n This is allowed to be overridden, but probably is not necessary\n in most scenarios."]
    pub write_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_encode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Small stash of channel info values. This is faster than calling\n malloc when the channel count in the part is small (RGBAZ),\n which is super common, however if there are a large number of\n channels, it will allocate space for that, so do not rely on\n this being used."]
    pub _quick_chan_store: [exr_coding_channel_info_t; 5usize],
}
#[test]
fn bindgen_test_layout__exr_encode_pipeline() {
    const UNINIT: ::std::mem::MaybeUninit<_exr_encode_pipeline> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_exr_encode_pipeline>(),
        512usize,
        concat!("Size of: ", stringify!(_exr_encode_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<_exr_encode_pipeline>(),
        8usize,
        concat!("Alignment of ", stringify!(_exr_encode_pipeline))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pipe_size) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(pipe_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).channel_count) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(channel_count)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).encode_flags) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(encode_flags)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).part_index) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(part_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).encoding_user_data) as usize
                - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(encoding_user_data)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_buffer) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_buffer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_bytes) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_bytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_alloc_size) as usize
                - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sample_count_table) as usize
                - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(sample_count_table)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sample_count_alloc_size) as usize
                - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(sample_count_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_sample_count_table) as usize
                - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_sample_count_table)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_sample_count_bytes) as usize
                - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_sample_count_bytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_sample_count_alloc_size) as usize
                - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_sample_count_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).compressed_buffer) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(compressed_buffer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).compressed_bytes) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(compressed_bytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).compressed_alloc_size) as usize
                - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(compressed_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scratch_buffer_1) as usize
                - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(scratch_buffer_1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scratch_alloc_size_1) as usize
                - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(scratch_alloc_size_1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scratch_buffer_2) as usize
                - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(scratch_buffer_2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scratch_alloc_size_2) as usize
                - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(scratch_alloc_size_2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).alloc_fn) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(alloc_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_fn) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).convert_and_pack_fn) as usize
                - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(convert_and_pack_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).compress_fn) as usize - ptr as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(compress_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).yield_until_ready_fn) as usize
                - ptr as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(yield_until_ready_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).write_fn) as usize - ptr as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(write_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._quick_chan_store) as usize
                - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(_quick_chan_store)
        )
    );
}
#[doc = " Struct meant to be used on a per-thread basis for writing exr data.\n\n As should be obvious, this structure is NOT thread safe, but rather\n meant to be used by separate threads, which can all be accessing\n the same context concurrently."]
pub type exr_encode_pipeline_t = _exr_encode_pipeline;
extern "C" {
    #[doc = " Initialize the encoding pipeline structure with the channel info\n for the specified part based on the chunk to be written.\n\n NB: The encode_pipe->pack_and_convert_fn field will be `NULL` after this. If that\n stage is desired, initialize the channel output information and\n call exr_encoding_choose_default_routines()."]
    pub fn exr_encoding_initialize(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Given an initialized encode pipeline, find an appropriate\n function to shuffle and convert data into the defined channel\n outputs.\n\n Calling this is not required if a custom routine will be used, or\n if just the raw decompressed data is desired."]
    pub fn exr_encoding_choose_default_routines(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Given a encode pipeline previously initialized, update it for the\n new chunk to be written.\n\n In this manner, memory buffers can be re-used to avoid continual\n malloc/free calls. Further, it allows the previous choices for\n the various functions to be quickly re-used."]
    pub fn exr_encoding_update(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Execute the encoding pipeline."]
    pub fn exr_encoding_run(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Free any intermediate memory in the encoding pipeline.\n\n This does NOT free any pointers referred to in the channel info\n areas, but rather only the intermediate buffers and memory needed\n for the structure itself."]
    pub fn exr_encoding_destroy(
        ctxt: exr_const_context_t,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
#[doc = " Struct meant to be used on a per-thread basis for reading exr data\n\n As should be obvious, this structure is NOT thread safe, but rather\n meant to be used by separate threads, which can all be accessing\n the same context concurrently."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _exr_decode_pipeline {
    #[doc = " Used for versioning the decode pipeline in the future.\n\n \\ref EXR_DECODE_PIPELINE_INITIALIZER"]
    pub pipe_size: usize,
    #[doc = " The output channel information for this chunk.\n\n User is expected to fill the channel pointers for the desired\n output channels (any that are `NULL` will be skipped) if you are\n going to use exr_decoding_choose_default_routines(). If all that is\n desired is to read and decompress the data, this can be left\n uninitialized.\n\n Describes the channel information. This information is\n allocated dynamically during exr_decoding_initialize()."]
    pub channels: *mut exr_coding_channel_info_t,
    pub channel_count: i16,
    #[doc = " Decode flags to control the behavior."]
    pub decode_flags: u16,
    #[doc = " Copy of the parameters given to the initialize/update for\n convenience."]
    pub part_index: ::std::os::raw::c_int,
    pub context: exr_const_context_t,
    pub chunk: exr_chunk_info_t,
    #[doc = " How many lines of the chunk to skip filling, assumes the\n pointer is at the beginning of data (i.e. includes this\n skip so does not need to be adjusted"]
    pub user_line_begin_skip: i32,
    #[doc = " How many lines of the chunk to ignore at the end, assumes the\n output is meant to be N lines smaller"]
    pub user_line_end_ignore: i32,
    #[doc = " How many bytes were actually decoded when items compressed"]
    pub bytes_decompressed: u64,
    #[doc = " Can be used by the user to pass custom context data through\n the decode pipeline."]
    pub decoding_user_data: *mut ::std::os::raw::c_void,
    #[doc = " The (compressed) buffer.\n\n If `NULL`, will be allocated during the run of the pipeline.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub packed_buffer: *mut ::std::os::raw::c_void,
    #[doc = " Used when re-using the same decode pipeline struct to know if\n chunk is changed size whether current buffer is large enough."]
    pub packed_alloc_size: usize,
    #[doc = " The decompressed buffer (unpacked_size from the chunk block\n info), but still packed into storage order, only needed for\n compressed files.\n\n If `NULL`, will be allocated during the run of the pipeline when\n needed.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub unpacked_buffer: *mut ::std::os::raw::c_void,
    #[doc = " Used when re-using the same decode pipeline struct to know if\n chunk is changed size whether current buffer is large enough."]
    pub unpacked_alloc_size: usize,
    #[doc = " For deep or other non-image data: packed sample table\n (compressed, raw on disk representation)."]
    pub packed_sample_count_table: *mut ::std::os::raw::c_void,
    pub packed_sample_count_alloc_size: usize,
    #[doc = " Usable, native sample count table. Depending on the flag set\n above, will be decoded to either a cumulative list (n, n+m,\n n+m+o, ...), or an individual table (n, m, o, ...). As an\n optimization, if the latter individual count table is chosen,\n an extra int32_t will be allocated at the end of the table to\n contain the total count of samples, so the table will be n+1\n samples in size."]
    pub sample_count_table: *mut i32,
    pub sample_count_alloc_size: usize,
    #[doc = " A scratch buffer of unpacked_size for intermediate results.\n\n If `NULL`, will be allocated during the run of the pipeline when\n needed.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub scratch_buffer_1: *mut ::std::os::raw::c_void,
    #[doc = " Used when re-using the same decode pipeline struct to know if\n chunk is changed size whether current buffer is large enough."]
    pub scratch_alloc_size_1: usize,
    #[doc = " Some decompression routines may need a second scratch buffer (zlib).\n\n If `NULL`, will be allocated during the run of the pipeline when\n needed.\n\n If the caller wishes to take control of the buffer, simple\n adopt the pointer and set it to `NULL` here. Be cognizant of any\n custom allocators."]
    pub scratch_buffer_2: *mut ::std::os::raw::c_void,
    #[doc = " Used when re-using the same decode pipeline struct to know if\n chunk is changed size whether current buffer is large enough."]
    pub scratch_alloc_size_2: usize,
    #[doc = " Enable a custom allocator for the different buffers (if\n decoding on a GPU). If `NULL`, will use the allocator from the\n context."]
    pub alloc_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: exr_transcoding_pipeline_buffer_id_t,
            arg2: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Enable a custom allocator for the different buffers (if\n decoding on a GPU). If `NULL`, will use the allocator from the\n context."]
    pub free_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: exr_transcoding_pipeline_buffer_id_t,
            arg2: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Function chosen to read chunk data from the context.\n\n Initialized to a default generic read routine, may be updated\n based on channel information when\n exr_decoding_choose_default_routines() is called. This is done such that\n if the file is uncompressed and the output channel data is\n planar and the same type, the read function can read straight\n into the output channels, getting closer to a zero-copy\n operation. Otherwise a more traditional read, decompress, then\n unpack pipeline will be used with a default reader.\n\n This is allowed to be overridden, but probably is not necessary\n in most scenarios."]
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_decode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function chosen based on the compression type of the part to\n decompress data.\n\n If the user has a custom decompression method for the\n compression on this part, this can be changed after\n initialization.\n\n If only compressed data is desired, then assign this to `NULL`\n after initialization."]
    pub decompress_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_decode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function which can be provided if you have bespoke handling for\n non-image data and need to re-allocate the data to handle the\n about-to-be unpacked data.\n\n If left `NULL`, will assume the memory pointed to by the channel\n pointers is sufficient."]
    pub realloc_nonimage_data_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_decode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function chosen based on the output layout of the channels of the part to\n decompress data.\n\n This will be `NULL` after initialization, until the user\n specifies a custom routine, or initializes the channel data and\n calls exr_decoding_choose_default_routines().\n\n If only compressed data is desired, then leave or assign this\n to `NULL` after initialization."]
    pub unpack_and_convert_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_decode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Small stash of channel info values. This is faster than calling\n malloc when the channel count in the part is small (RGBAZ),\n which is super common, however if there are a large number of\n channels, it will allocate space for that, so do not rely on\n this being used."]
    pub _quick_chan_store: [exr_coding_channel_info_t; 5usize],
}
#[test]
fn bindgen_test_layout__exr_decode_pipeline() {
    const UNINIT: ::std::mem::MaybeUninit<_exr_decode_pipeline> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_exr_decode_pipeline>(),
        504usize,
        concat!("Size of: ", stringify!(_exr_decode_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<_exr_decode_pipeline>(),
        8usize,
        concat!("Alignment of ", stringify!(_exr_decode_pipeline))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pipe_size) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(pipe_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).channel_count) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(channel_count)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).decode_flags) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(decode_flags)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).part_index) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(part_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).user_line_begin_skip) as usize
                - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(user_line_begin_skip)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).user_line_end_ignore) as usize
                - ptr as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(user_line_end_ignore)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).bytes_decompressed) as usize
                - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(bytes_decompressed)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).decoding_user_data) as usize
                - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(decoding_user_data)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_buffer) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(packed_buffer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_alloc_size) as usize
                - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(packed_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unpacked_buffer) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(unpacked_buffer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unpacked_alloc_size) as usize
                - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(unpacked_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_sample_count_table) as usize
                - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(packed_sample_count_table)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).packed_sample_count_alloc_size) as usize
                - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(packed_sample_count_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sample_count_table) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(sample_count_table)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sample_count_alloc_size) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(sample_count_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scratch_buffer_1) as usize
                - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(scratch_buffer_1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scratch_alloc_size_1) as usize
                - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(scratch_alloc_size_1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scratch_buffer_2) as usize
                - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(scratch_buffer_2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scratch_alloc_size_2) as usize
                - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(scratch_alloc_size_2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).alloc_fn) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(alloc_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_fn) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_fn) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).decompress_fn) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(decompress_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).realloc_nonimage_data_fn) as usize
                - ptr as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(realloc_nonimage_data_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unpack_and_convert_fn) as usize
                - ptr as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(unpack_and_convert_fn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._quick_chan_store) as usize
                - ptr as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(_quick_chan_store)
        )
    );
}
#[doc = " Struct meant to be used on a per-thread basis for reading exr data\n\n As should be obvious, this structure is NOT thread safe, but rather\n meant to be used by separate threads, which can all be accessing\n the same context concurrently."]
pub type exr_decode_pipeline_t = _exr_decode_pipeline;
extern "C" {
    #[doc = " Initialize the decoding pipeline structure with the channel info\n for the specified part, and the first block to be read.\n\n NB: The decode->unpack_and_convert_fn field will be `NULL` after this. If that\n stage is desired, initialize the channel output information and\n call exr_decoding_choose_default_routines()."]
    pub fn exr_decoding_initialize(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Given an initialized decode pipeline, find appropriate functions\n to read and shuffle/convert data into the defined channel outputs.\n\n Calling this is not required if custom routines will be used, or if\n just the raw compressed data is desired. Although in that scenario,\n it is probably easier to just read the chunk directly using\n exr_read_chunk()."]
    pub fn exr_decoding_choose_default_routines(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Given a decode pipeline previously initialized, update it for the\n new chunk to be read.\n\n In this manner, memory buffers can be re-used to avoid continual\n malloc/free calls. Further, it allows the previous choices for\n the various functions to be quickly re-used."]
    pub fn exr_decoding_update(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Execute the decoding pipeline."]
    pub fn exr_decoding_run(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Free any intermediate memory in the decoding pipeline.\n\n This does *not* free any pointers referred to in the channel info\n areas, but rather only the intermediate buffers and memory needed\n for the structure itself."]
    pub fn exr_decoding_destroy(
        ctxt: exr_const_context_t,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Computes a buffer that will be large enough to hold the compressed\n data. This may include some extra padding for headers / scratch"]
    pub fn exr_compress_max_buffer_size(in_bytes: usize) -> usize;
}
extern "C" {
    #[doc = " Compresses a buffer using a zlib style compression.\n\n If the level is -1, will use the default compression set to the library\n \\ref exr_set_default_zip_compression_level\n data. This may include some extra padding for headers / scratch"]
    pub fn exr_compress_buffer(
        ctxt: exr_const_context_t,
        level: ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_void,
        in_bytes: usize,
        out: *mut ::std::os::raw::c_void,
        out_bytes_avail: usize,
        actual_out: *mut usize,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Decompresses a buffer using a zlib style compression."]
    pub fn exr_uncompress_buffer(
        ctxt: exr_const_context_t,
        in_: *const ::std::os::raw::c_void,
        in_bytes: usize,
        out: *mut ::std::os::raw::c_void,
        out_bytes_avail: usize,
        actual_out: *mut usize,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Apply simple run length encoding and put in the output buffer."]
    pub fn exr_rle_compress_buffer(
        in_bytes: usize,
        in_: *const ::std::os::raw::c_void,
        out: *mut ::std::os::raw::c_void,
        out_bytes_avail: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Decode run length encoding and put in the output buffer."]
    pub fn exr_rle_uncompress_buffer(
        in_bytes: usize,
        max_len: usize,
        in_: *const ::std::os::raw::c_void,
        out: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " Routine to query the lines required per chunk to compress with the\n specified method.\n\n This is only meaningful for scanline encodings, tiled\n representations have a different interpretation of this.\n\n These are constant values, this function returns -1 if the compression\n type is unknown."]
    pub fn exr_compression_lines_per_chunk(
        comptype: exr_compression_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Exposes a method to apply compression to a chunk of data.\n\n This can be useful for inheriting default behavior of the\n compression stage of an encoding pipeline, or other helper classes\n to expose compression.\n\n NB: As implied, this function will be used during a normal encode\n and write operation but can be used directly with a temporary\n context (i.e. not running the full encode pipeline)."]
    pub fn exr_compress_chunk(
        encode_state: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Exposes a method to decompress a chunk of data.\n\n This can be useful for inheriting default behavior of the\n uncompression stage of an decoding pipeline, or other helper classes\n to expose compress / uncompress operations.\n\n NB: This function will be used during a normal read and decode\n operation but can be used directly with a temporary context (i.e.\n not running the full decode pipeline)."]
    pub fn exr_uncompress_chunk(
        decode_state: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Debug function: print to stdout the parts and attributes of the\n context @p c"]
    pub fn exr_print_context_info(
        c: exr_const_context_t,
        verbose: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
